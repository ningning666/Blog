<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/Blog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/Blog/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/Blog/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/Blog/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="小怪兽成长记">
<meta property="og:url" content="https://ningning666.github.io/Blog/page/2/index.html">
<meta property="og:site_name" content="小怪兽成长记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小怪兽成长记">





  
  
  <link rel="canonical" href="https://ningning666.github.io/Blog/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>小怪兽成长记</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/Blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小怪兽成长记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">

    
    
    
      
    

    

    <a href="/Blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>主页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/Blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-分类">

    
    
    
      
    

    

    <a href="/Blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">

    
    
    
      
    

    

    <a href="/Blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/16.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/16.html" class="post-title-link" itemprop="url">盒模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-04 14:31:43" itemprop="dateCreated datePublished" datetime="2019-09-04T14:31:43+08:00">2019-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-24 15:21:33" itemprop="dateModified" datetime="2019-09-24T15:21:33+08:00">2019-09-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/CSS权威指南/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h2><p>元素盒子的属性分为以下三类：</p>
<ul>
<li>边框： 可以设置边框的宽窄、样式和颜色；</li>
<li>内边距：可以设置盒子内容区与边框的间距；</li>
<li>外边距：可以设置盒子与相邻元素的间距。</li>
</ul>
<p>如下面的这个盒模型示意图所示，展示了HTML 元素的边框、内边距和外边距之间的关系<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="attr"></p>
<p>外边距是边框向外推其他元素，而内边距是从边框向内推元素的内容，一个盒子有4条边，因此与边框、内边距和外边距相关的属性也各有4个，分别是上（top）、右（right）、下（bottom）、左（left）。<br><strong>CSS提供了简写样式</strong><br>CSS为边框、内边距和外边距分别规定了简写属性，可以通过一条声明就可以完成设定，在每个简写声明中，属性值的顺序都是上、右、下、左（顺时针旋转顺序）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">不使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin-top:5px;</span><br><span class="line">    margin-right:10px;</span><br><span class="line">    margin-bottom:12px;</span><br><span class="line">    margin-left:8px;</span><br><span class="line">&#125;</span><br><span class="line">使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin:5px 10px 12px 8px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：4个值之间有空格，但不能是其他分隔符（比如逗号之类的），甚至不用把4值都写出来，如果哪个值没有写，就使用对边的值。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    margin:12px 10px 6px;     <span class="comment">#最后一个值没有写就会使用对边的值即10px</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    margin:12px;         <span class="comment">#4个边都取这个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个盒子的属性也分三种粒度，到底选择哪个粒度的属性，要看你想选择哪条边，以及那条边的哪个属性，这三种粒度从一般到特殊分别是举例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 全部三个属性，全部4条边</span><br><span class="line">&#123;</span><br><span class="line">    border:2px dashed red;</span><br><span class="line">&#125;</span><br><span class="line">2. 1个属性，全部4条边</span><br><span class="line">&#123;</span><br><span class="line">    border-style:dashed;</span><br><span class="line">&#125;</span><br><span class="line">3. 1个属性，1条边</span><br><span class="line">&#123;</span><br><span class="line">    border-left-style:dashed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合使用这三种粒度的简写属性达成设计目标是很常见的，。比如说吧，我想为盒子的上边和下边添加4 像素宽的红色边框，为左边添加1 像素宽的红色边框，而右边没有边框。可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;border:4px solid red;&#125; /* 先给4 条边设置相同的样式 */</span><br><span class="line">&#123;border-left-width:1px;&#125; /* 修改左边框宽度 */</span><br><span class="line">&#123;border-right:none;&#125; /* 移除右边框 */</span><br></pre></td></tr></table></figure>

<h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>边框有3个相关属性</p>
<ul>
<li>宽度(border-width)：可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值；</li>
<li>样式(border-style): 有none、hidden、dotted、dashed、solid、double、groove、ridge、inset 和outset 等文本值。</li>
<li>颜色(border-color): 可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.warning &#123;border:solid <span class="comment">#f33;&#125;                #所有带有warning类的段落都会带有一个4像素宽的红色实心边框</span></span><br><span class="line">p.warning &#123;border-width:4px 1px 1px 4px;&#125;     <span class="comment">#修改边框宽度</span></span><br></pre></td></tr></table></figure>

<h3 id="盒子内边距-padding"><a href="#盒子内边距-padding" class="headerlink" title="盒子内边距(padding)"></a>盒子内边距(padding)</h3><p>内边距是盒子内容区与盒子边框之间的距离。同样遵从简写样式，依据上、右、下、左的顺序。</p>
<h3 id="盒子外边距-margin"><a href="#盒子外边距-margin" class="headerlink" title="盒子外边距(margin)"></a>盒子外边距(margin)</h3><p>推荐使用下面的这条规则作为样式表的第一条规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;margin:0; padding:0;&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同需要修改外边距与内边距。</p>
<h3 id="叠加外边距"><a href="#叠加外边距" class="headerlink" title="叠加外边距"></a>叠加外边距</h3><p>垂直方向上的边距会叠加，但是像下例这样上下边距相遇时，他们就会相互叠加，直到一个外边距碰到另一个元素的边框。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*为简明起见，省略了字体声明*/</span><br><span class="line">p &#123;height:50px; border:1px solid <span class="comment">#000; backgroundcolor:#fff; margin-top:50px;</span></span><br><span class="line">margin-bottom:30px;&#125;</span><br></pre></td></tr></table></figure>

<p>上例中的第一段的下外边距与第二段的上外边距之间的外边距是50像素，不是（50+30），因为外边距叠加。<strong>较宽的外边距决定两个元素最终离多远</strong></p>
<h3 id="外边距的单位"><a href="#外边距的单位" class="headerlink" title="外边距的单位"></a>外边距的单位</h3><p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间<br>距，不受字号变大或变小的影响。而对于上、下外边距，以em 为单位则可以让段间距随字号变化而相应增大或缩小，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为30 像素*/</span><br><span class="line">p &#123;font-size:1em; margin:.75em 30px;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮动与清除"><a href="#浮动与清除" class="headerlink" title="浮动与清除"></a>浮动与清除</h2><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>CSS 设计float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性居然也成了创建多栏布局最简单的方式。</p>
<ol>
<li><strong>文本绕排图片：为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后再写环绕它的文本。</strong><br>示例如下：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">       /*为简明起见，省略了字体声明*/</span><br><span class="line">        p &#123;margin:0; border:1px solid red;&#125;</span><br><span class="line">        /*外边距防止图片紧挨文本*/</span><br><span class="line">        img &#123;<span class="built_in">float</span>:left; margin:0 4px 4px 0;&#125;</span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;img src=<span class="string">"images/acoustic_nylon1.jpg"</span> alt=<span class="string">"nylon string acoustic guitar"</span> /&gt;</span><br><span class="line">        &lt;p&gt;Do you know，guitar?I very like guitar!It<span class="string">'s my favorite a kind of instrument! If you don'</span>t know guitar,piease <span class="built_in">read</span> this article.I believe the article will be very helpful to you!</span><br><span class="line">        The guitar is used <span class="keyword">for</span> various musical style, it <span class="keyword">in</span> the pop music, rock music, r&amp;b, folk music, Buddha brother Ming is regarded as the main instrument. There are also <span class="keyword">in</span> the guitar classical music, there have been a lot of solo, selects a use of and orchestra. It usually have six strings, but there are four strings, eight and ten strings, ten strings ErXian. There are two main categories: guitar ShiYou <span class="built_in">history</span>, a wooden sound box with the timber guitar, 8031 ErShiEr 10th century were invented, electric guitars 8031. Loudspeakers Timber guitar is usually used to classical music, folk music and popular music. Guitars are often used to, rock music, blues and pop music. The invention of receiving of western pop culture and music had important influence.</span><br><span class="line">        Now,<span class="keyword">do</span> you learn guitar and love it?&lt;/p&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon1.png" alt="attr"></p>
<p><strong>浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。</strong></p>
<p>2.<strong>创建分栏</strong><br>在此基础上创建多栏，只要再用一次float 属性，如下图所示，只要给段落设定宽度，然后也浮动它即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#123;<span class="built_in">float</span>:left; margin:0; width:300px; border:1px solid red;&#125;</span><br><span class="line">img &#123;<span class="built_in">float</span>:left; margin:0 4px 4px 0;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon2.png" alt="attr"></p>
<h3 id="围住浮动元素的三种方法"><a href="#围住浮动元素的三种方法" class="headerlink" title="围住浮动元素的三种方法"></a>围住浮动元素的三种方法</h3><p>如果出现下面的这种情况应该怎么办？<strong>底部的标题跑到右边去了</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;border:1px solid blue; margin:0 0 10px 0;&#125;</span><br><span class="line">img &#123;<span class="built_in">float</span>:left;&#125;</span><br><span class="line">footer &#123;border:1px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/float1.png" alt="attr"></p>
<p><strong>方法一：为父元素添加overflow:hidden，以强制它包围浮动元素。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;border:1px solid blue; margin:0 0 10px 0; overflow:hidden;&#125;</span><br><span class="line">img &#123;<span class="built_in">float</span>:left;&#125;</span><br><span class="line">p &#123;border:1px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：同时浮动父元素。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;border:1px solid blue; <span class="built_in">float</span>:left; width:100%;&#125;</span><br><span class="line">img &#123;<span class="built_in">float</span>:left;&#125;</span><br><span class="line">footer &#123;border:1px solid red; clear:left;&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意：由于section浮动了，所有为了强制footer依然呆在section 下方，要给它应用clear:left。</p>
<p><strong>方法三：添加非浮动的清除元素。</strong><br>强制父元素包含其浮动子元素的方法，就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。在包含元素最后添加子元素作为清除元素的方式有两种。<br><strong>第一种如下所示：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        section &#123;border:1px solid blue;&#125;</span><br><span class="line">        img &#123;<span class="built_in">float</span>:left;&#125;</span><br><span class="line">        .clear_me &#123;clear:left;&#125;</span><br><span class="line">        footer &#123;border:1px solid red;&#125;</span><br><span class="line">     &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">            &lt;img src=<span class="string">"images/acoustic_nylon1.jpg"</span> alt=<span class="string">"nylon string acoustic guitar"</span> /&gt;</span><br><span class="line">            &lt;p&gt;It is fun to <span class="built_in">float</span>.&lt;/p&gt;</span><br><span class="line">            &lt;div class=<span class="string">"clear_me"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">        &lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第二种如下所示：</strong> 用CSS 来添加这个清除元素的方法，添加clearfix类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#html 部分</span></span><br><span class="line">&lt;section class=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span><br><span class="line">    &lt;p&gt;It is fun to <span class="built_in">float</span>.&lt;/p&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## CSS样式</span></span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">content:<span class="string">"."</span>;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用clear:both 意味着section 中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用left，但both 也适用于将来图片float:right 的情况。</strong></p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS 布局的核心是position 属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。position 属性有4 个值：static(静态定位)、relative(相对定位)、absolute(绝对定位)、fixed(固定定位)，默认值为static。<br>从完全移出文档流的角度说，固定定位与绝对定位类似。<strong>但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动</strong></p>
<h2 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h2><p>把元素的position 属性设定为relative、absolute 或fixed 后，继而可以使用top、right、bottom 和left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。<br>示例代码如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"inner"</span>&gt;This is text…&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#搭配下面的CSS</span></span><br><span class="line">div<span class="comment">#outer &#123;width:250px; margin:50px 40px; border-top:3px solid red;&#125;</span></span><br><span class="line">div<span class="comment">#inner &#123;position:absolute; top:10px; left:20px; background:#ccc;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="显示属性"><a href="#显示属性" class="headerlink" title="显示属性"></a>显示属性</h2><p>正如所有元素都有position 属性，所有元素也都有display 属性。尽管display 属性的值有很多，但大多数元素display 属性的默认值不是block，就是inline</p>
<ul>
<li>块级元素，比如段落、标题、列表等，在浏览器中上下堆叠显示。</li>
<li>行内元素，比如a、span 和img，在浏览器中左右并排显示，只有前一行没有空间时才会显示到下一行。</li>
</ul>
<p>把块级元素变成行内元素（或者相反）的魔法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*默认为block*/</span><br><span class="line">p &#123;display:inline;&#125;</span><br><span class="line">/*默认为inline*/</span><br><span class="line">a &#123;display:block;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CSS中每个元素盒子都可以想象成由两个图层组成，元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image 属性），背景图片叠加在背景颜色之上</p>
<h3 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h3><p>CSS规定以下与背景相关属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">background-color</span><br><span class="line">background-image</span><br><span class="line">background-repeat</span><br><span class="line">background-position</span><br><span class="line">background-size</span><br><span class="line">background-attachment</span><br><span class="line">background(简写属性)</span><br><span class="line">background-clip、background-origin、background-break（目前尚未得到广泛支持）</span><br></pre></td></tr></table></figure>

<p><strong>背景颜色：</strong>background-color 是背景属性中最简单的，通过它可以设定元素的颜色。然后，元素就会以设定的颜色填充背景图层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background-color:<span class="comment">#caebff;&#125;</span></span><br><span class="line">p &#123;/*盒子布局样式*/</span><br><span class="line">    font-family:helvetica, arial, sans-serif; font-size:18px;</span><br><span class="line">    width:350px; margin:20px auto; padding:10px;</span><br><span class="line">    /*这个例子中讨论背景和前景样式*/</span><br><span class="line">    background-color:<span class="comment">#fff; color:#666; border:4px solid;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中body 的background-color 是蓝绿色，段落的background-color是白色，前景色color是灰色，前景色既影响文本，也影响边框。</p>
<p><strong>背景图片</strong>默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域，背景图片来源方式如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(图片路径/图片文件名)</span><br></pre></td></tr></table></figure>

<p><strong>要改变默认的水平和垂直重复效果，可以修改background-repeat 属性；要改变背景图片的起点，可以修改background-position 属性。</strong></p>
<p><strong>背景重复：</strong>控制背景重复方式的background-repeat属性有4个值。默认值就是repeat，效果就是水平和垂直方向都重复，直至填满元素的背景区域为止。<br>另外3个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y 和在任何方向上都不重复（或者说只让背景图片显示一次）的no-repeat。</p>
<ul>
<li>background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景区域。</li>
<li>background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应<br>背景区域。</li>
</ul>
<p><strong>背景位置：</strong>控制背景位置的background-position 属性，是所有背景属性中最复杂的。background-position 属性有5个关键字值，分别是top、left、bottom、right 和center，这些关键字中的任意两个组合起来都可以作为该属性的值<br>background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/*center center 的简化写法*/</span><br><span class="line">p<span class="comment">#center &#123;background-position:center;&#125;   #相当于background-position:center cetner</span></span><br></pre></td></tr></table></figure>

<p>background-position:center center 设定图片中心点与元素中心点重合，然后再向各个方向重复<br><strong>设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。</strong></p>
<p><strong>背景尺寸：</strong>background-size 是CSS3 规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给它设定的值及含义如下。</p>
<ul>
<li>50%：缩放图片，使其填充背景区的一半。</li>
<li>100px 50px：把图片调整到100 像素宽，50 像素高。</li>
<li>cover：拉大图片，使其完全填满背景区；保持宽高比。</li>
<li>contain：缩放图片，使其恰好适合背景区；保持宽高比。</li>
</ul>
<p><strong>背景粘附：</strong>background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。<br>background-attachment:fixed 最常用于给body元素中心位置添加淡色水印，让水印不随页面滚动而移动。实现这种效果的CSS 规则如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-image:url(images/watermark.png);</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-color:<span class="comment">#fff;</span></span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">    background-size:contain;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写背景属性：</strong>background 属性可以用来设定所有背景相关的值。比如，前面那个backgroundattachment的例子使用简写的background 属性，可以写成这样一条规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background:url(images/watermark.png) center <span class="comment">#fff no-repeat contain fixed;&#125;</span></span><br></pre></td></tr></table></figure>

<p>声明中少写了哪个属性的值（比如没写no-repeat），就会使用相应属性的默认值（repeat）。</p>
<h3 id="其他CSS3-背景属性"><a href="#其他CSS3-背景属性" class="headerlink" title="其他CSS3 背景属性"></a>其他CSS3 背景属性</h3><p>background-clip: 控制背景绘制区域的范围，比如可以让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。默认情况下，背景绘制区域是扩展到边框外边界的。<br>background-origin: 控制背景定位区域的原点，可以设定为元素盒子左上角以外的位置。比如，可以设定以内容区左上角作为原点。<br>background-break: 控制分离元素（比如跨越多行的行内盒子）的显示效果。</p>
<h3 id="多背景图片"><a href="#多背景图片" class="headerlink" title="多背景图片"></a>多背景图片</h3><p>CSS3 还可以给元素背景添加多个背景图片，下面我们就使用简写属性background来说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    height:150px;</span><br><span class="line">    width:348px;</span><br><span class="line">    border:2px solid <span class="comment">#aaa;</span></span><br><span class="line">    margin:20px auto;</span><br><span class="line">    font:24px/150px helvetica, arial, sansserif;</span><br><span class="line">    text-align:center;</span><br><span class="line">    background:</span><br><span class="line">    url(images/turq_spiral.png) 30px -10px no-repeat,</span><br><span class="line">    url(images/pink_spiral.png) 145px 0px no-repeat,</span><br><span class="line">    url(images/gray_spiral.png) 140px -30px no-repeat, <span class="comment">#ffbd75;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.png" alt="attr"></p>
<h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><p>渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。<br>下面来看一个简单的线性渐变的例子，HTML 标记如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">'gradient1'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">'gradient2'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=<span class="string">'gradient3'</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>CSS 规则如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*为元素盒子添加样式*/</span><br><span class="line">div &#123;</span><br><span class="line">    height:150px;</span><br><span class="line">    width:200px;</span><br><span class="line">    border:1px solid <span class="comment">#ccc;</span></span><br><span class="line">    <span class="built_in">float</span>:left;</span><br><span class="line">    margin:16px;</span><br><span class="line">&#125;</span><br><span class="line">/*例1：默认为从上到下*/</span><br><span class="line">.gradient1 &#123;</span><br><span class="line">background:linear-gradient(<span class="comment">#e86a43, #fff);</span></span><br><span class="line">&#125;</span><br><span class="line">/*例2：从左到右*/</span><br><span class="line">.gradient2 &#123;</span><br><span class="line">background:linear-gradient(left, <span class="comment">#64d1dd, #fff);</span></span><br><span class="line">&#125;</span><br><span class="line">/*例3：左上到右下*/</span><br><span class="line">.gradient3 &#123;</span><br><span class="line">background:linear-gradient(-45deg, <span class="comment">#e86a43, #fff);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了三种简单的渐变效果。例1 声明了一种开始属性和一种结束颜色，这两种颜色会按照默认的方向（从下到下）实现平滑过渡。例2 起点关键字left，于是渐变方向变成了从左到另一端。例3 声明了-45deg（deg 是“度”），等于把起点从默认的中上设定到了左上。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%B8%89%E7%A7%8D%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.png" alt="attr"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/10.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/10.html" class="post-title-link" itemprop="url">HTML标记与文档结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-29 19:53:16" itemprop="dateCreated datePublished" datetime="2019-08-29T19:53:16+08:00">2019-08-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-24 15:18:50" itemprop="dateModified" datetime="2019-09-24T15:18:50+08:00">2019-09-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/CSS权威指南/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CSS的用途就是为HTML标记添加样式，所以，我们首先要先知道怎么编写和构造HTML标记，才能让CSS更方便地为它添加样式。用HTML标记内容的目的是为了赋予网页语义，我们平常用的浏览器、给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的Web爬虫都是用户代理，它们需要显示、朗读和分析网页。HTML规定了一组标签，用来给内容打上不同的标记，每个标签都是对所包含内容的一种描述，最常用的HTML标签描述的是标题、段落、链接和图片。目前，HTML一共有114个标签，但按照80/20的原则，使用其中25个左右的标签就可以满足80%的标记需要。<br>在给内容都打上标记之后，就可以使用CSS来给标签添加样式了，添加样式的依据有标签名、标签属性（如id和class）、以及标签与其他标签在标记中的相对位置关系，等等。HTML标签也会构成一个层次化的文档，从而可以通过CSS来设置网页的布局，为每个元素应用你想要的样式。</p>
<h2 id="HTML标记基础"><a href="#HTML标记基础" class="headerlink" title="HTML标记基础"></a>HTML标记基础</h2><h3 id="文本用闭合标签格式如下"><a href="#文本用闭合标签格式如下" class="headerlink" title="文本用闭合标签格式如下"></a>文本用闭合标签格式如下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;标签名&gt;文本内容&lt;/标签名&gt;</span><br></pre></td></tr></table></figure>

<p>标题、段落等文本元素都要求闭合标签，也就是要有一个开标签和一个闭标签</p>
<h3 id="引用内容用自闭合标签格式如下"><a href="#引用内容用自闭合标签格式如下" class="headerlink" title="引用内容用自闭合标签格式如下"></a>引用内容用自闭合标签格式如下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;标签名 属性_1=<span class="string">"属性值"</span> 属性_n=<span class="string">"属性值"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>非文本内容是通过自闭合标签显示的，比如图片等，闭合标签与自闭合标签的区别在于闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的引用。浏览器会在HTML页面加载的时候，额外想服务器发送请求，以取得自闭合标签引用的内容。下面就是使用自闭合标签标记的一张图片。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"images/cisco.jpg"</span> alt=<span class="string">"My dog Cisco"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性负责为浏览器提供有关标签的额外信息，比如说，前面例子中的<code>&lt;img&gt;</code>标签有两个属性，一个属性是src(source，来源)，属性值是cisco.jpg，这个属性定义了图片的来源是一个名为cisco.jpg的文件，另一个属性是alt(alternative，替代内容)，定义的是在图片因故未能加载成功时在屏幕上显示的文本。</p>
<p><strong>视障用户使用的屏幕阅读器会大声读出alt属性的内容，因此一定要给<code>&lt;img&gt;</code>标签的这个alt属性添加让人一听（或一看）就能明白的内容。</strong></p>
<h3 id="标题与段落"><a href="#标题与段落" class="headerlink" title="标题与段落"></a>标题与段落</h3><p>一般来说，网页都会以一个<code>&lt;h1&gt;</code>标签开头，其中的文本用于告诉读者这个网页是干什么的，然后用<code>&lt;h2&gt;</code>标记下一级内容，或许是一个副标题，然后才是<code>&lt;h3&gt;</code>，以此类推。<br><code>&lt;h1&gt;</code>不仅是最大最突出的标题（除非你用CSS缩小它的字号），搜索引擎也会将其视为仅次于<code>&lt;title&gt;</code>标签的另一个搜索关键词的来源。<br>段落用于标记主要的文本内容，是所有文本元素中出场率最高的一个，简言之，只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。</p>
<h3 id="复合元素"><a href="#复合元素" class="headerlink" title="复合元素"></a>复合元素</h3><p>HTML不仅规定了标题、图片和段落等基本的内容标记，还规定了用于创建列表、表格和表单等复杂用户界面组件的标记，这些就是所谓的复合元素，即它们是由多个标签共同完成的。比如，<code>&lt;li&gt;</code>是一个列表项，它只在<code>&lt;ol&gt;</code>(有序列表)和<code>&lt;ul&gt;</code>(无序列表)中才有效，在<code>&lt;dl&gt;</code>(定义列表)中则无效。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;Save HTML file&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Move file to Web server via FTP&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;Preview <span class="keyword">in</span> browser&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/HTML%E5%A4%8D%E5%90%88%E5%85%83%E7%B4%A0.png" alt="attr"></p>
<h3 id="嵌套标签"><a href="#嵌套标签" class="headerlink" title="嵌套标签"></a>嵌套标签</h3><p>在上面的例子中，基于<code>&lt;li&gt;</code>标签与<code>&lt;ol&gt;</code>标签的嵌套关系，可以说<code>&lt;li&gt;</code>标签是<code>&lt;ol&gt;</code>标签的子标签（或子元素），或者说<code>&lt;ol&gt;</code>标签是<code>&lt;li&gt;</code>标签的夫标签（父元素）。<br>**注意：在一个标签里嵌套另一个标签必须先关闭后一个标签再关闭前一个标签，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;That car is &lt;em&gt;fast&lt;/em&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>HTML文档的结构正是通过类似这样的标签嵌套，以及就此建立起来标签间的“父——子”关系形成的。</p>
<h2 id="HTML文档剖析"><a href="#HTML文档剖析" class="headerlink" title="HTML文档剖析"></a>HTML文档剖析</h2><h3 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h3><p>按照HTML5语法编写的最简单的HTML页面的模板可以写成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!-- 这里是网页内容--&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>模板的第一行代码是一种新语法，或者说是一种简化的DOCTYPE，这一行就是为了声明： “以下是一个HTML文档。”<strong>这个标签不用关闭。</strong><br><code>&lt;html&gt;</code>标签是根级标签，页面中所有的其他标签都嵌套在这个标签内部，而且它的闭标签也是整个页面中的最后一个闭标签，<code>&lt;html&gt;</code>标签只有两个直接的子标签：<code>&lt;head&gt;</code>和
<code>&lt;body&gt;</code>。
帮助浏览器理解页面的信息都包含在<code>&lt;head&gt;</code>标签中，在上面的例子中，<code>&lt;head&gt;</code>标签里只包含<code>&lt;meta&gt;</code>和<code>&lt;title&gt;</code>两个标签，其中<code>&lt;meta&gt;</code>标签中有一个charset属性，它是在告诉浏览器这个页面使用的是UTF-8编码，<code>&lt;title&gt;</code>标签的文本会在页面显示时，作为整个页面的标题出现在浏览器窗口顶部的标题栏中。<br><code>&lt;body&gt;</code>标签则包含着标记所有内容的HTML元素。</p>
<h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><p><strong>下面介绍一些块级标签和行内标签：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">块级标签</span><br><span class="line">&lt;h1&gt;-&lt;h6&gt;: 6级标签，&lt;h1&gt;表示最重要</span><br><span class="line">&lt;p&gt;: 段落</span><br><span class="line">&lt;lo&gt;: 有序列表</span><br><span class="line">&lt;li&gt;：列表项</span><br><span class="line">&lt;blockquote&gt;: 独立引用</span><br><span class="line">行内标签</span><br><span class="line">&lt;a&gt;：链接（anchor，锚）</span><br><span class="line">&lt;img&gt;: 图片</span><br><span class="line">&lt;em&gt;：斜体</span><br><span class="line">&lt;strong&gt;：重要</span><br><span class="line">&lt;abbr&gt;：简写</span><br><span class="line">&lt;cite&gt;: 引证</span><br><span class="line">&lt;q&gt;: 文本内引用</span><br></pre></td></tr></table></figure>

<p>几乎所有HTML元素的display属性值要么是block，要么是inline。最明显的一个例外是table元素，它有自己的display属性值。<br>块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行，而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情况下才会折到下一行显示。</p>
<p><strong>使用块级元素和行内元素构建页面：</strong> 示例如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;Block and Inline Elements&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Types of Guitars&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Guitars come <span class="keyword">in</span> two main types: electric and acoustic.&lt;/p&gt;</span><br><span class="line">    &lt;h2&gt;Acoustic Guitars&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;Acoustic guitars have a large hollow body that projects the sound of the strings.&lt;/p&gt;</span><br><span class="line">    &lt;h3&gt;Nylon String Acoustic Guitars&lt;/h3&gt;</span><br><span class="line">    &lt;p&gt;Descendants of the gut-strung instruments pf yore,nylon string guitars have a mellow tone.&lt;/p&gt;</span><br><span class="line">    &lt;h2&gt;Electric Guitars&lt;/h2&gt;</span><br><span class="line">    &lt;img src=<span class="string">"images/acoustic_nylon.jpg"</span> alt=<span class="string">"nylon string acoustic guitar"</span> /&gt;</span><br><span class="line">    &lt;p&gt;Electric guitars have a solid or hollow body with pickups that capture the string vibration so it can be amplified.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2.png" alt="attr"></p>
<h3 id="嵌套的元素"><a href="#嵌套的元素" class="headerlink" title="嵌套的元素"></a>嵌套的元素</h3><p>嵌套标记实际上就是嵌套盒子，在后面CSS盒模型重点介绍</p>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><p>HTML结构所对应的文档对象模型（以下简称”DOM”）,DOM是从浏览器的视角观察页面中的元素以及每个元素的属性，由此得出这些元素的一个家族树，通过DOM可以确定元素之间的相互关系，在CSS中引用DOM中特定的位置，就可以选中响应的HTML元素，并修改其样式属性。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h1&gt;The Document Object Model&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;The page<span class="string">'s HTMLmarkup structure defines the DOM.&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/section&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于这个例子中的DOM层次，我们可以做如下表述。</p>
<ul>
<li>section是h1和p的父元素，也是直接祖先元素；</li>
<li>h1和p是section的子元素，也是直接后代元素；</li>
<li>h1和p是同胞元素，它们有共同的父元素section;</li>
<li>section、h1和p是body的后代元素，或者下面的元素（嵌套在后者的内部）；</li>
<li>section和body是h1和p的祖先元素，或者上面的元素（在某一层次上包含后者）。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/13.html" class="post-title-link" itemprop="url">媒体查询</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-28 15:32:29" itemprop="dateCreated datePublished" datetime="2019-08-28T15:32:29+08:00">2019-08-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-11 09:45:56" itemprop="dateModified" datetime="2019-11-11T09:45:56+08:00">2019-11-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/CSS权威指南/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>媒体查询提供一种查询语法去扩展媒体类型，这种查询语法可以更加具体地为用户的设备提供样式，媒体查询可以给你一种自由，让网站真正地与设备无关，不管用户如何访问网站，都为它们提供最佳的合适体验。</p>
<h2 id="媒体查询的优点"><a href="#媒体查询的优点" class="headerlink" title="媒体查询的优点"></a>媒体查询的优点</h2><p>媒体查询会基于设备的属性来检测设备，这样就不需要使用浏览器探测脚本，之后允许直接安装设备的功能区设定目标样式表，所以如果检测到用户适应小屏幕的设备，CSS规则就会调整以适应该屏幕尺寸，从屏幕上去掉无关元素，提供更小的图片，让文本变得更加清晰。</p>
<h2 id="HTML-lt-link-gt-标签"><a href="#HTML-lt-link-gt-标签" class="headerlink" title="HTML&lt;link&gt;标签"></a>HTML<code>&lt;link&gt;</code>标签</h2><p>实例：链接一个外部样式表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> <span class="built_in">type</span>=<span class="string">"text/css"</span> href=<span class="string">"theme.css"</span>/&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>在用于样式表时，<code>&lt;link&gt;</code>标签得到了几乎所有浏览器的支持，但是几乎没有浏览器支持其他方面的用途。<br><strong>定义和用法：</strong><br><code>&lt;link&gt;</code> 标签定义文档与外部资源的关系。<br><code>&lt;link&gt;</code> 标签最常见的用途是链接样式表。<br><strong>HTML 与 XHTML 之间的差异:</strong></p>
<p>第一种是使用<code>&lt;link&gt;</code>元素区调用一个外部样式表：<br>在 HTML 中，<code>&lt;link&gt;</code> 标签没有结束标签。<br>在 XHTML 中，<code>&lt;link&gt;</code> 标签必须被正确地关闭。<br><strong>提示和注释：</strong><br>注释：link 元素是空元素，它仅包含属性。<br>注释：此元素只能存在于 head 部分，不过它可出现任何次数。<br><strong>属性：这里仅介绍HTML5中的新属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>值</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>href</td>
        <td>URL</td>
        <td>规定被链接文档的位置。</td>
    </tr>
    <tr>
        <td>hreflang</td>
        <td>language_code</td>
        <td>规定被链接文档中文本的语言。</td>
    </tr>
    <tr>
        <td>media</td>
        <td>media_query</td>
        <td>规定被链接文档将被显示在什么设备上。</td>
    </tr>
    <tr>
        <td rowspan="13">rel</td>
        <td>alternate</td>
        <td rowspan="13">规定当前文档与被链接文档之间的关系。</td>
    </tr>
    <tr>
        <td>author</td>
    </tr>
    <tr>
        <td>help</td>
    </tr>
    <tr>
        <td>icon</td>
    </tr>
    <tr>
        <td>licence</td>
    </tr>
    <tr>
        <td>next</td>
    </tr>
    <tr>
        <td>pingback</td>
    </tr>
    <tr>
        <td>prefetch</td>
    </tr>
    <tr>
        <td>prev</td>
    </tr>
    <tr>
        <td>search</td>
    </tr>
    <tr>
        <td>sidebar</td>
    </tr>
    <tr>
        <td>tag</td>
    </tr>
    <tr>
        <td>stylesheet</td>
    </tr>
    <tr>
        <td rowspan="2">sizes</td>
        <td>heightxwidth</td>
        <td rowspan="2">规定被链接资源的尺寸。仅适用于 rel="icon"。</td>
    </tr>
    <tr>
        <td>any</td>
    </tr>
    <tr>
        <td>type</td>
        <td>MIME_type</td>
        <td>规定被链接文档的 MIME 类型。</td>
    </tr>
</table>

<p><strong>全局属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>accesskey</td>
        <td>规定激活元素的快捷键。</td>
    </tr>
    <tr>
        <td>class</td>
        <td>规定元素的一个或多个类名（引用样式表中的类）</td>
    </tr>
    <tr>
        <td>contenteditable</td>
        <td>规定元素内容是否可编辑。</td>
    </tr>
    <tr>
        <td>contextmenu</td>
        <td>规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</td>
    </tr>
    <tr>
        <td>data-*</td>
        <td>用于存储页面或应用程序的私有定制数据。</td>
    </tr>
    <tr>
        <td>dir</td>
        <td>规定元素中内容的文本方向。</td>
    </tr>
    <tr>
        <td>draggle</td>
        <td>规定元素是否可拖动。</td>
    </tr>
    <tr>
        <td>dropzone</td>
        <td>规定在拖动被拖动数据时是否进行复制、移动或链接。</td>
    </tr>
    <tr>
        <td>hidden</td>
        <td>规定元素仍未或不再相关。</td>
    </tr>
    <tr>
        <td>id</td>
        <td>规定元素的唯一 id。</td>
    </tr>
    <tr>
        <td>lang</td>
        <td>规定元素内容的语言。</td>
    </tr>
    <tr>
        <td>spellcheck</td>
        <td>规定是否对元素进行拼写和语法检查。</td>
    </tr>
    <tr>
        <td>style</td>
        <td>规定元素的行内 CSS 样式。</td>
    </tr>
    <tr>
        <td>tabindex</td>
        <td>规定元素的 tab 键次序。</td>
    </tr>
    <tr>
        <td>title</td>
        <td>规定有关元素的额外信息。</td>
    </tr>
    <tr>
        <td>translate</td>
        <td>规定是否应该翻译元素内容。</td>
    </tr>
</table>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询设置了一个参数（或者一系列参数），如果设备在查看页面的时候具有与该参数匹配的属性，就会显示与之相关的样式规则。有三种方式使用媒体查询，它们是和我们把CSS应用到文档中的不同方式相匹配的，第一种是使用一个link元素去调用一个外部样式表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"file"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"logic media and (expression)"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第二种是使用@import指令调用外部的样式表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(<span class="string">'file'</span>) logic media and (expression);</span><br></pre></td></tr></table></figure>

<p>第三种是在一个嵌入的style元素中或在样式表本身利用扩展的@media规则使用媒体查询：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media logic media and (expression) &#123; rules &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/9.html" class="post-title-link" itemprop="url">第六章 面向对象的程序设计</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-24 20:15:33" itemprop="dateCreated datePublished" datetime="2019-08-24T20:15:33+08:00">2019-08-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-21 21:30:57" itemprop="dateModified" datetime="2019-09-21T21:30:57+08:00">2019-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/JavaScript高级程序设计/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或者函数。</p>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>创建自定义对象的最简单方式就是创建一个object的实例，然后再为它添加属性和方法，创建对象有两种方式，最常用的是对象字面量语法形式，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript中有两种属性：数据属性和访问器属性。<br>数据属性：包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Enumerable]]: 表示能否通过<span class="keyword">for</span>-in循环返回属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Writable]]: 表示能否修改属性的值，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Value]]: 包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置，特性默认值为undefined。</span><br></pre></td></tr></table></figure>

<p>要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法，这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符对象的属性必须是：configurable、enumerable、writable和value，设置其中的一个或多个值，可以修改对应的特性值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(person.name);  <span class="comment">#"Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line">console.log(person.name);  <span class="comment">#"Nicholas"</span></span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person.name);  <span class="comment">#"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>访问器属性：访问器属性不包括数据值，它们包含一对儿getter和setter函数（不过，这两个函数都不是必须的），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下4个特性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Enumerable]]: 表示能否通过<span class="keyword">for</span>-in循环返回属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Get]]: 在读取属性时调用的函数，默认值为undefined；</span><br><span class="line">[[Set]]: 在写入属性时调用的函数，默认值为undefined。</span><br></pre></td></tr></table></figure>

<p>访问器属性同样不能直接定义，需要使用Object.defineProperty()来定义，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    _year: 2004,</span><br><span class="line">    edition: 1</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>: <span class="keyword">function</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;2004) &#123;</span><br><span class="line">            this._year = newValue;</span><br><span class="line">            this.edition += newValue - 2004;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = 2015;</span><br><span class="line">console.log(book.edition);    <span class="comment">#12</span></span><br><span class="line">console.log(book._year);      <span class="comment">#2015</span></span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性，而访问器属性year则包含一个getter函数和一个setter函数，设置一个属性的值导致其他属性发生变化是使用访问器属性的常用方式。区别于python的访问限制。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>Object.defineProperties() 方法可以通过描述符一次定义多个属性，这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应，实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> this._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;2004) &#123;</span><br><span class="line">                this._year = newValue;</span><br><span class="line">                this.edition += newValue - 2004;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码在book对外上定义了两个数据属性（_year和edition)和一个访问器属性（year）。最终的对象与上面例子中的定义的对象相同。<br>唯一的区别是这里的属性都是在同一时间创建的。</p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符，这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: 2004</span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        get: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> this._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">set</span>: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;2004) &#123;</span><br><span class="line">                this._year = newValue;</span><br><span class="line">                this.edition += newValue - 2004;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var descriptor = Object.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">console.log(descriptor.value);      <span class="comment">#2004</span></span><br><span class="line">console.log(descriptor.configurable);  <span class="comment">#false</span></span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createPerson(name,age,job) &#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = createPerson(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">var person2 = createPerson(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>);</span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: <span class="string">'Nicholas'</span>, age: 29, job: <span class="string">'Software Engineer'</span>, sayName: [Function] &#125;</span><br><span class="line">&#123; name: <span class="string">'Greg'</span>, age: 27, job: <span class="string">'Doctor'</span>, sayName: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次地调用这个函数，而且每次它都能返回一个包含三个属性一个方法的对象，解决了创建多个相似对象的问题，但是仍没有解决对象识别的为题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，将前面工厂模式的例子重写成构造函数如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age,job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">var person2 = new Person(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>);</span><br><span class="line">console.log(person1);</span><br><span class="line">console.log(person2)</span><br></pre></td></tr></table></figure>

<p>输出结果与上面相同，Person()与createPerson()函数存在以下几点不同：</p>
<ul>
<li>没有显示地创建对象；</li>
<li>直接将属性和方法赋给了this对象；</li>
<li>没有return语句</li>
</ul>
<p><strong>注意：构造函数的函数名按照惯例以大写字母开头，创建构造函数的新实例必须使用new操作符</strong>。
构造函数胜过工厂函数的地方就是创建自定义的构造函数可以将它的实例标识为一种特定的类型，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1 instanceof Object);   <span class="comment">#true</span></span><br><span class="line">console.log(person1 instanceof Person);   <span class="comment">#true</span></span><br><span class="line">console.log(person2 instanceof Object);   <span class="comment">#true</span></span><br><span class="line">console.log(person2 instanceof Person)    <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p><strong>将构造函数当作函数：</strong>构造函数与其他函数的唯一区别在于调用它们的方式不同，任何函数，只要通过new操作符来调用，就可以作为构造函数；如果不通过new操作符来调用，就是普通函数。如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当作构造函数使用</span></span><br><span class="line">var person = new Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName();  <span class="comment"># "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>);   <span class="comment">#添加到window</span></span><br><span class="line">window.sayName();   <span class="comment">#"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在另一个对象的作用域中调用</span></span><br><span class="line">var o = new Object();</span><br><span class="line">Person.call(o, <span class="string">"Keisten"</span>, 25, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName();   <span class="comment">#"Keisten"</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数仍然存在的一些问题：</strong>使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍，比如person1与person2都有一个名为sayName()方法，但不是同一个Function()的实例，也可以将方法转移到构造函数之外，定义在全局作用域上，但是这样就没有封装性可言了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.sayName == person2.sayName)   <span class="comment">#false</span></span><br></pre></td></tr></table></figure>

<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，就是不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">person1.sayName();   <span class="comment">#"Nicholas"</span></span><br><span class="line">var person2 = new Person();</span><br><span class="line">person2.sayName();   <span class="comment">#"Nicholas"</span></span><br><span class="line"></span><br><span class="line">console.log(person1.sayName == person2.sayName);  <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>新对象的这些属性和方法是由所有实例共享的，即person1和person2访问的都是同一组属性和同一个sayName()函数，因此要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。</p>
<p><strong>理解原型对象:</strong></p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，其他方法都是从Object继承而来的，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。这个指针叫[[Prototype]]。<br>以前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="attr"></p>
<p>上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.isPrototypeOf(person1));   <span class="comment">#true</span></span><br><span class="line">console.log(Person.prototype.isPrototypeOf(person2));   <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>Object.getPrototypeOf()方法返回[[Prototype]]的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getPrototypeOf(person1) == Person.prototype);   <span class="comment">#true</span></span><br><span class="line">console.log(Object.getPrototypeOf(person1).name)        <span class="comment">#"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果在实例中添加了一个属性，而该属性与原型中的一个属性同名，则在实例中创建该属性，该属性会屏蔽掉原型中的那个属性。</strong></p>
<p><strong>原型与in操作符:</strong></p>
<p>有两种方式使用in操作符：单独使用和在for-in循环中使用，在单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<br>hasOwnProperty()只在属性存在于实例中才返回true，当同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中还是存在于原型中，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line">console.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">#true</span></span><br><span class="line">console.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);          <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line">console.log(person2.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">#false</span></span><br><span class="line">console.log(<span class="string">"name"</span> <span class="keyword">in</span> person2);           <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括于存在于实例中的属性，也包括存在于原型中的属性，屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性）的实例属性也会在for-in循环中返回。<br>使用ECMAScript5的<strong>Object.keys()方法</strong>能取得对象上所有可枚举的实例属性，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">var keys = Object.keys(Person.prototype);</span><br><span class="line">console.log(keys);   <span class="comment">#[ 'name', 'age', 'job', 'sayName' ]</span></span><br></pre></td></tr></table></figure>

<p>如果要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.getOwnPropertyNames(Person.prototype);   <span class="comment">#[ 'constructor', 'name', 'age', 'job', 'sayName' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>更简单的原型语法:</strong></p>
<p>前面例子中每一个属性和方法就要敲一遍Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，因此用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var friend = new Person();</span><br><span class="line">console.log(friend instanceof Object);      <span class="comment">#true</span></span><br><span class="line">console.log(friend instanceof Person);      <span class="comment">#true</span></span><br><span class="line">console.log(friend.constructor == Person);  <span class="comment">#false</span></span><br><span class="line">console.log(friend.constructor == Object);   <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p><strong>原型的动态性:</strong></p>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象的所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();     <span class="comment">#"hi"</span></span><br></pre></td></tr></table></figure>

<p>即使Person实例friend是在添加新方法之前创建的，但它仍然可以访问这个新方法，其原因可以归结于实例与原型之间的松散连接关系，当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型，因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。<br>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，情况就会不同，调用构造函数时回味实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系，<strong>实例中的指针仅指向原型，而不指向构造函数。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span> () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    consttructor: Person,</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();     <span class="comment">#error:friend.sayHi is not a function</span></span><br></pre></td></tr></table></figure>

<p><strong>原生对象的原型:</strong></p>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的，所有原生引用类型（Object、Array、String等等）都在其构造函数上定义了方法，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof Array.prototype.sort);  //<span class="keyword">function</span></span><br><span class="line">console.log(typeOf String.prototype.substring);  //<span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。比如下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.startsWith = <span class="keyword">function</span> (text) &#123;</span><br><span class="line">    <span class="built_in">return</span> this.indexOf(text)  == 0;</span><br><span class="line">&#125;;</span><br><span class="line">var msg = <span class="string">"Hello World"</span>;</span><br><span class="line">console.log(msg.startsWith(<span class="string">"Hello"</span>));  <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p><strong>原型对象的问题:</strong></p>
<p>1.原型对象省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值<br>2.原型中所有属性是被很多实例共享的，这种共享对于函数非常合适，但是对于包含引用类型值的属性来说，问题就突出了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>],</span><br><span class="line">    sayName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line">console.log(person1.friends);      <span class="comment">#[ 'Shelby', 'Court', 'Van' ]</span></span><br><span class="line">console.log(person2.friends);      <span class="comment">#[ 'Shelby', 'Court', 'Van' ]</span></span><br><span class="line">console.log(person1.friend == person2.friend);  <span class="comment">##true</span></span><br></pre></td></tr></table></figure>

<p>上面的问题是很少有人单独使用原型模式的原因所在。</p>
<h3 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="headerlink" title="组合使用构造函数模式与原型模式"></a>组合使用构造函数模式与原型模式</h3><p>创造自定义函数的最常见方式，就是组合使用构造函数和原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存；另外，这种混成模式还支持向构造函数传递参数，可谓是集两种模式之长。如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age,job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [<span class="string">"Shely"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">var person2 = new Person(<span class="string">"Greg"</span>, 25, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">console.log(person1.friends);             <span class="comment">#[ 'Shely', 'Court', 'Van' ]</span></span><br><span class="line">console.log(person2.friends);             <span class="comment">#[ 'Shely', 'Court' ]</span></span><br><span class="line">console.log(person1.friends === person2.friends); <span class="comment">#false</span></span><br><span class="line">console.log(person1.sayName === person2.sayName);  <span class="comment">#true</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的，修改person1.friend（向其中传入一个新字符串），并不会影响到person2.friends，因为它们分别引用了不同的数组。<br><strong>这种构造函数与原型模式混合的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法，可以说，这是用来定义引用类型的一种默认模式。</strong></p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式是针对独立的构造函数和原型产生的，动态原型模式将所有信息都封装在构造函数中，通过在构造函数中初始化原型（仅在必要的条件下），又保持了同时使用构造函数和原型的优点，换句话说，可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。如下例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age,job) &#123;</span><br><span class="line">    <span class="comment"># 属性</span></span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法</span></span><br><span class="line">    <span class="keyword">if</span>(typeof this.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment"># "Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>若是前面几种模式都不适用，可以选择使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用是封装对象的代码，然后再返回新创建的对象，但是从表面来看，这个函数又很像是典型的构造函数，但是除了使用new操作符并把使用的函数叫做构造函数之外，这个模式其实和工厂模式是一模一样的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age,job) &#123;</span><br><span class="line">    var o = new Object();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var friend = new Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();       <span class="comment">#"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>**这个模式可以在特殊的情况下用来为对象创建构造函数，假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式。<br>如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SpecialArray</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 创建数组</span></span><br><span class="line">    var values = new Array();</span><br><span class="line">    <span class="comment"># 添加值</span></span><br><span class="line">    values.push.apply(values,arguments);</span><br><span class="line">    <span class="comment"># 添加方法</span></span><br><span class="line">    values.toPipeString = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 返回数组</span></span><br><span class="line">    <span class="built_in">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var colors = new SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line">console.log(colors.toPipeString());     <span class="comment">#"red|blue|green"</span></span><br></pre></td></tr></table></figure>

<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象，稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this，二是不使用new操作符调用构造函数，按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Person(name,age,job) &#123;</span><br><span class="line">    <span class="comment">#创建要返回的对象</span></span><br><span class="line">    var o = new Object();</span><br><span class="line">    <span class="comment">#可以在这里定义私有变量和函数</span></span><br><span class="line">    <span class="comment">#添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        console.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment"># 返回对象</span></span><br><span class="line">    <span class="built_in">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line">var friend = Person(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();     <span class="comment">#"Nicholas"</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法，由于ECMAScript函数没有签名，因此无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，实现原型链有一种基本模式，其代码大致如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SuperType</span></span>() &#123;</span><br><span class="line">    this.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</span><br><span class="line">    this.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 继承了SuperType</span></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.getSuperValue());    <span class="comment">#"true"</span></span><br></pre></td></tr></table></figure>

<p>以上代码定义了两个类型：SuperType和SubType，每个类型分别有一个属性和一个方法，它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的，实现的本质是重写原型对象，代之以一个新类型的实例。<br>调用原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.getSuperValue，最后一步找到该方法，在找不到属性或者方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<p><strong>别忘记默认的属性：</strong>所有的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype，这也是所有自定义类型都会继承toString()、valueof()等默认方法的根本原因，即上面的例子展示的原型链还应该包括另外一个继承层次。</p>
<p><strong>确定原型与实例的关系：</strong>可以通过两种方式来确定原型和实例之间的关系，第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(instance instanceof Object);     <span class="comment">#"true"</span></span><br><span class="line">console.log(instance instanceof SuperType);  <span class="comment">#"true"</span></span><br><span class="line">console.log(instance instanceof SubType);   <span class="comment">#"true"</span></span><br></pre></td></tr></table></figure>

<p>第二种方法是使用isPrototypeOf()方法，同样只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.prototype.isPrototypeOf(instance));       <span class="comment">#"true"</span></span><br><span class="line">console.log(SuperType.prototype.isPrototypeOf(instance));    <span class="comment">#"true"</span></span><br><span class="line">console.log(SubType.prototype.isPrototypeOf(instance));      <span class="comment">#"true"</span></span><br></pre></td></tr></table></figure>

<p><strong>谨慎地定义方法：</strong></p>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
<li>在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。</li>
</ul>
<p><strong>原型链的问题：</strong><br>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题，其中，最重要的问题来自包含引用类型值的原型。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Supertype</span></span>() &#123;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new Supertype();</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(instance1.colors);     <span class="comment">#[ 'red', 'blue', 'green', 'black' ]</span></span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors)      <span class="comment">#[ 'red', 'blue', 'green', 'black' ]</span></span><br></pre></td></tr></table></figure>

<p>当SubType通过原型链继承了Supertype之后，SubType.prototype就变成了Supertype的一个实例，因此它也拥有了一个它自己的colors属性，就跟专门创建了一个SubType.prototype.colors属性一样，结果是<strong>SubType的所有实例都会共享这一个colors属性。</strong><br>原型链的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br><strong>基于以上两个问题，实践中很少单独使用原型链。</strong></p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>的技术（有时也叫做伪造函数或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。**而且函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Supertype</span></span>() &#123;</span><br><span class="line">    this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</span><br><span class="line">    <span class="comment">#继承了Supertype</span></span><br><span class="line">    Supertype.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors)</span><br></pre></td></tr></table></figure>

<p>代码中Supertype.call(this)“借调”了超类型的构造函数，通过使用call()方法（或apply()方法），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了Supertype构造函数，这样在新SubType对象上执行SubType()函数中定义的所有对象初始化代码，结果SubType的每个实例就会有自己的colors属性的副本了。</p>
<p><strong>传递参数：</strong>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Supertype(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">SubType</span></span>() &#123;</span><br><span class="line">    Supertype.call(this, <span class="string">"Nicholas"</span>);</span><br><span class="line">    this.age = 29;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.name);     <span class="comment">#"Nicholas"</span></span><br><span class="line">console.log(instance.age);      <span class="comment">#29</span></span><br></pre></td></tr></table></figure>

<p><strong>借用构造函数的问题：</strong>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数复用就无从谈起了，而且在超类型的原型中定义的方法对于类型而言也是不可见的，结果所有类型都只能使用构造函数模式，考虑到这些，<strong>借用构造函数的技术也是很少单独使用的。</strong></p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，主要思想<strong>是使用原型链是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>，这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/8.html" class="post-title-link" itemprop="url">第五章 引用类型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-16 09:33:59" itemprop="dateCreated datePublished" datetime="2019-08-16T09:33:59+08:00">2019-08-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 15:41:42" itemprop="dateModified" datetime="2019-08-30T15:41:42+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/JavaScript高级程序设计/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>引用类型的值（对象）是引用类型的一个实例，在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br></pre></td></tr></table></figure>

<p>这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型（例如Object），以便开发人员用以实现常见的计算任务。</p>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建Object类型的方式有两种，第一种是使用new操作符后跟Object构造函数，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用对象字面量的方法，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对象字面量语法，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;      <span class="comment">#与new Object()相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>

<p>**开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。</p>
<p>访问对象属性有两种办法：点表示法和方括号表示法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person[<span class="string">"name"</span>]); <span class="comment"># "Nicholas"</span></span><br><span class="line">console.log(person.name);    <span class="comment"># "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>从功能上看，这两种访问对象属性的方法没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var propertyName = <span class="string">"name"</span>;</span><br><span class="line">console.log(person[propertyName]);  <span class="comment"># "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>Array类型与Object类型一样都是ECMAScript中最常用的类型，ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据，创建数组的基本方式有两种，第一种是使用Array构造函数，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br></pre></td></tr></table></figure>

<p>创建数组也可以按照下面几种方式进行创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(20);  <span class="comment">#创建length为20的数组</span></span><br><span class="line">var colors = new Array(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);  <span class="comment"># 创建了一个包含三个字符串值的数组</span></span><br><span class="line">var colors = new Array(3); <span class="comment"># 创建一个包含3项的数组</span></span><br><span class="line">var colors = new Array(<span class="string">"Grey"</span>); <span class="comment">#创建一个包含1项，即字符串"Grey"的数组</span></span><br></pre></td></tr></table></figure>

<p>在使用Array构造函数时也可以省略new操作符，省略new操作符与不省略new操作符的结果相同。</p>
<p>创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">#创建一个包含3个字符串的数组</span></span><br><span class="line">var name = [];   <span class="comment">#创建一个空数组</span></span><br><span class="line">var values = [1,2,];   <span class="comment">#不要这样！这样会创建一个包含2项或3项的数组</span></span><br><span class="line">var options = [,,,,,]; <span class="comment">#不要这样！这样会创建一个包含5项或6项的数组</span></span><br></pre></td></tr></table></figure>

<p>在读取和设置数组的值时，要使用方括号并提供响应值的基于0的数字索引，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">#定义一个字符串数组</span></span><br><span class="line">console.log(color[0]);  <span class="comment">#显示第一项</span></span><br><span class="line">color[2] = <span class="string">"black"</span>;  <span class="comment">#修改第三项</span></span><br><span class="line">color[3] = <span class="string">"brown"</span>;  /新增第四项</span><br><span class="line">console.log(colors.length); <span class="comment">#4</span></span><br></pre></td></tr></table></figure>

<p>上面例子的数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除或向数组中添加新项，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = 2;</span><br><span class="line">console.log(colors[2]); <span class="comment">#undefined</span></span><br></pre></td></tr></table></figure>

<p>下面介绍数组会用到的一些方法</p>
<h3 id="检测数组方法"><a href="#检测数组方法" class="headerlink" title="检测数组方法"></a>检测数组方法</h3><p>ECMAScript新增Array.isArray()方法，这个方法能确定某个值最终到底是不是数组，不管在哪个全局环境下创建的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Array.isArray(value)) &#123;</span><br><span class="line">    <span class="comment">#对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组继承的toString()返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串，valueOf()返回的还是数组。<br>使用join()方法，则可以使用不同的分隔符来构建字符串，join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">console.log(colors.toString());</span><br><span class="line">console.log(colors.valueOf());</span><br><span class="line">console.log(colors.join(<span class="string">"||"</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red,blue,green</span><br><span class="line">[ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span> ]</span><br><span class="line">red||blue||green</span><br></pre></td></tr></table></figure>

<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。<br>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；pop()方法则从数组末尾移除最后一项，减少数组的length()值，然后返回移除的项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">var item = colors.pop();</span><br><span class="line">console.log item;  <span class="comment">#"black"</span></span><br><span class="line">console.log(colors.length);  <span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>实现这一操作的方法有两组：<br>从数组末端添加项，从数组前端取得项：push()与shift()方法<br>从数组前端添加项，从数组末端取得项：unshift()与pop()方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">var item = colors.shift();</span><br><span class="line">console.log(item); <span class="comment">#"red"</span></span><br><span class="line">console.log(colors.length); <span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用push()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”red”,”green”,”black”，在调用shift()方法时，移除并返回的是第一项，即”red”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array();</span><br><span class="line">var count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>);</span><br><span class="line">console.log(count);  <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">var item = colors.pop();</span><br><span class="line">console.log(item); <span class="comment">#"green"</span></span><br><span class="line">console.log(colors.length); <span class="comment">#2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用unshift()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”black”,”red”,”green”，在调用pop()方法时，移除并返回的是最后一项，即”green”。</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>reverse()方法：反转数组项的顺序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">values.reverse();</span><br><span class="line">console.log(values);  <span class="comment">#5,4,3,2,1</span></span><br></pre></td></tr></table></figure>

<p>sort()方法：按照升序或者降序顺序排列数组项，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，然后接收一个比较函数作为参数，以确定排列顺序。<br>示例如下：这个示例是按照升序进行排列的，若是按照降序排列，只需交换比较函数返回的值即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(value1,value2) &#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [0,1,5,10,15];</span><br><span class="line">values.sort(compare);</span><br><span class="line">console.log(values)；  <span class="comment"># 0，1，5，10，15</span></span><br></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>要介绍的concat()方法、slice()方法都不影响原始数组。<br>concat()方法：可以基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">var colors2 = colors1.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line"></span><br><span class="line">console.log(colors1);  <span class="comment">#red,green,blue</span></span><br><span class="line">console.log(colors2);  <span class="comment">#red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>

<p>slice()方法：能够基于当前数组中的一个或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；如果有两个参数，该方法返回起始和结束位置之间的项但不包括结束位置的项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line">var colors2 = colors1.slice(1);</span><br><span class="line">var colors3 = colors1.slice(1,4);</span><br><span class="line"></span><br><span class="line">console.log(colors2);  <span class="comment">#green,blue,yellow,purple</span></span><br><span class="line">console.log(clolors3); <span class="comment">#green,blue,yellow</span></span><br></pre></td></tr></table></figure>

<p>splice()方法：该方法包括对原始数组的删除、插入以及替换功能</p>
<ul>
<li>删除：可以删除任意数量的项，只需提供2个参数：要删除的第一项的位置和要删除的项数；</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项；</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项，插入的项不必等于删除的项数。<br>实例如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">var removed = colors.splice(0,1);   <span class="comment">#删除第一项</span></span><br><span class="line">console.log(colors);  <span class="comment"># green,blue</span></span><br><span class="line">console.log(removed); <span class="comment"># red</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(1,0,<span class="string">"yellow"</span>, <span class="string">"orange"</span>);  <span class="comment">#从位置1开始插入两项</span></span><br><span class="line">console.log(colors);  <span class="comment"># green,yellow,orange,blue</span></span><br><span class="line">console.log(removed); <span class="comment"># 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(1,1,<span class="string">"red"</span>, <span class="string">"purple"</span>);     <span class="comment">#插入两项，删除一项</span></span><br><span class="line">console.log(colors);  <span class="comment"># green,red,purple,orange,blue</span></span><br><span class="line">console.log(removed); <span class="comment"># yellow</span></span><br></pre></td></tr></table></figure>

<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()方法，这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1，在比较第一个参数与数组中的每一项时，使用全等操作符（===）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var colors = new Array(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>, <span class="string">"blue"</span>, <span class="string">"purple"</span>);</span><br><span class="line">console.log(colors.indexOf(<span class="string">"blue"</span>);  <span class="comment"># 1</span></span><br><span class="line">console.log(colors.indexOf(<span class="string">"blue"</span>,2);  <span class="comment"># 4</span></span><br><span class="line">console.log(colors.latIndexOf(<span class="string">"blue"</span>);  <span class="comment"># 4</span></span><br><span class="line">console.log(colors.indexOf(<span class="string">"yellow"</span>);  <span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比较时全等</span></span><br><span class="line">var str1 = new String(<span class="string">"blue"</span>);</span><br><span class="line">var str2 = <span class="string">"blue"</span>;</span><br><span class="line">console.log(typeof(str1));  <span class="comment">#object</span></span><br><span class="line">console.log(typeof(str2));  <span class="comment">#string</span></span><br><span class="line">console.log(colors.indexOf(str1));  <span class="comment">#-1</span></span><br><span class="line">console.log(colors.indexOf(str2));  <span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript提供了5个迭代方法，每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值,传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。以下方法都不会修改数组中的包含的值。</p>
<ul>
<li>every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数，这个方法没有返回值。</li>
<li>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。<br>实例如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1];</span><br><span class="line">var everyResult = numbers.every(<span class="keyword">function</span>(item,index,array)&#123;</span><br><span class="line">    <span class="built_in">return</span> (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(everyResult); <span class="comment">#false</span></span><br><span class="line"></span><br><span class="line">var someResult = numbers.some(<span class="keyword">function</span>(item,index,array)&#123;</span><br><span class="line">    <span class="built_in">return</span> (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(someResult); <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line">var filterResult = numbers.filter(funvtion(item,index,array)&#123;</span><br><span class="line">    rerurn (item &gt; 2);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(filterResult); <span class="comment"># [3,4,5,4,3]</span></span><br><span class="line"></span><br><span class="line">var mapResult = numbers.map(<span class="keyword">function</span>(item,index,array)&#123;</span><br><span class="line">    <span class="built_in">return</span> item * 2;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(mapResult); <span class="comment">#[2,4,6,8,10,8,6,4,2]</span></span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="keyword">function</span>(item,index,array&#123;</span><br><span class="line">    <span class="comment">#执行某些操作，这个方法没有返回值，本质上与for循环迭代数组一样</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>ECMAScript5新增了两个缩小数组的方法：reduce()和reduceRight()。这两个数组都会迭代数组的所有项，然后构建一个最终返回的值。<br>reduce()方法从数组的第一项开始，逐个遍历到最后；reduceRight()则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值，传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数就是数组的第一项，第二个参数就是数组的第二项。<br>使用reduce()方法可以执行求数组中所有值之和的操作，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5];</span><br><span class="line">var sum = values.reduce(<span class="keyword">function</span>(prev,cur,index,array)&#123;</span><br><span class="line">    <span class="built_in">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(sum); <span class="comment">#15</span></span><br></pre></td></tr></table></figure>

<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>ECMAScript中的Date类型是在早期Java中的java.utip.Date类基础上构建的，为此，Date类型使用自UTC1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。<br>要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var now = new Date();</span><br></pre></td></tr></table></figure>

<p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数，为了简化这一计算，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br>Date.parse()是Date对象的静态方法，parse()方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。<br>语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date.parse(datestring)</span><br></pre></td></tr></table></figure>

<p>UTC() 方法可根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。Date.UTC() 是一种静态方法，因为需要使用构造函数 Date() 来调用它，而不是通过某个 Date 对象调用。</p>
<p>Date.UTC() 方法的参数指定日期和时间，它们都是 UTC 时间，处于 GMT 时区。指定的UTC时间将转换成毫秒的形式，这样构造函数 Date() 和方法 Date.setTime() 就可以使用它了。<br>语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date.UTC(year,month,day,hours,minutes,seconds,ms)</span><br></pre></td></tr></table></figure>

<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>与其他引用类型一样，Date类型也重写了toLocalString()、toString()和valueOf()方法，但这些方法返回的值与其他类型中的方法不同。Date()类型的toLocalString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，这大致意味着时间格式中会包含AM或PM，但不会包含时区信息；而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。<br>Date类型的valueOf()方法则根本不返回字符串，而是返回日期的毫秒表示。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul>
<li><p>toDateString(): 以特定实现的格式显示星期几、月、日和年；</p>
</li>
<li><p>toTimeString(): 以特定于实现的格式显示时、分、秒和时区；</p>
</li>
<li><p>toLocalTimeString(): 以特定于实现的格式显示时、分、秒；</p>
</li>
<li><p>toLocalDateString(): 以特定于地区的格式显示星期几、月、日和年；</p>
</li>
<li><p>toUTCString(): 以特定于实现的格式显示完整的UTC日期。</p>
</li>
<li><p>还有很多关于日期的函数方法：</p>
</li>
</ul>
<p>更多参考：<a href="https:#www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">Date对象方法</a></p>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = /pattern/flags;</span><br></pre></td></tr></table></figure>

<p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标名正则表达式的行为，正则表达式的匹配模式支持下列3个标志：</p>
<ul>
<li>g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i: 表示不区分大小写模式，，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m: 表示多行模式，即在到达一行文末末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>因此一个正则表达式就是一个模式与上述3个标志的组合体，不同组合产生不同结果，如下面的例子所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 匹配字符串中所有<span class="string">"at"</span>的实例</span><br><span class="line"> */</span><br><span class="line">var patttern1 = /at/g;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配第一个<span class="string">"bat"</span>或者<span class="string">"cat"</span>，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var patttern2 = /[bc]at/i;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配字符串中所有以<span class="string">"at"</span>结尾的3个字符的组合，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var patttern3 = /.at/gi;</span><br></pre></td></tr></table></figure>

<p>与其他语言中的正则表达式一样，模式中所使用的所有元字符都必须转义，正则表达式中的元字符包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( | &#123; \ ^ $ ) ? * + . ]&#125;</span><br></pre></td></tr></table></figure>

<p>这些元字符在正则表达式中都有一或多种特殊用途，因此想要匹配字符串中包含的这些字符，就必须对它们进行转义，下面给出几个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 匹配第一个<span class="string">"bat"</span>或<span class="string">"cat"</span>，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var pattern1 = /[bc]at/i;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配第一个<span class="string">"[bc]at"</span>，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var pattern2 = /\[bc\]at/i;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配字符串中所有以<span class="string">"at"</span>结尾的3个字符的组合，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var patttern3 = /.at/gi;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 匹配字符串中所有以<span class="string">".at"</span>结尾的3个字符的组合，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var patttern4 = /\.at/gi;</span><br></pre></td></tr></table></figure>

<p>前面举得这些例子都是以字面量形式来定义的正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串，可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 匹配第一个<span class="string">"bat"</span>或<span class="string">"cat"</span>，不区分大小写</span><br><span class="line"> */</span><br><span class="line">var pattern1 = /[bc]at/i;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 与pattern1相同，只不过是使用构造函数创建的</span><br><span class="line"> */</span><br><span class="line">var pattern2 = new RegExp(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式u不一样，在ECMAScript3 中，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。<br>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var re = null,i;</span><br><span class="line"><span class="keyword">for</span> (i=0; i&lt;10; i++) &#123;</span><br><span class="line">    re = /cat/g;</span><br><span class="line">    console.log((re.text(<span class="string">"catastrophe"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=0; i&lt;10; i++)&#123;</span><br><span class="line">    re = new RegExp(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">    console.log(re.text(<span class="string">"catastrophe"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例，由于实例属性不会重置，所以在循环中再次调用text()方法会失败，这是因为第一次调用text()找到了”cat”，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以就找不到它了，由于会测试到字符串末尾，所以下一次再调用text()就又从开头开始了。<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式，因为每次迭代都会创建一个新的RegExp构造函数一样，每次创建新的RegExp实例。</p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global: 布尔值，表示是否设置了g标志；</li>
<li>ignoreCase: 布尔值，表示是否设置了i标志；</li>
<li>lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起；</li>
<li>multiline: 布尔值，表示是否设置了m标志；</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>实例如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var pattern1 = /\[bc]at/i;</span><br><span class="line">console.log(pattern1.global);    <span class="comment">#false</span></span><br><span class="line">console.log(pattern1.ignoreCase);  <span class="comment">#true</span></span><br><span class="line">console.log(pattern1.lastIndex);  <span class="comment">#0</span></span><br><span class="line">console.log(pattern1.multiline);  <span class="comment">#false</span></span><br><span class="line">console.log(pattern1.source);    <span class="comment">#"\[bc]at"</span></span><br><span class="line"></span><br><span class="line">var pattern2 = new RegExp(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line">console.log(pattern2.global);    <span class="comment">#false</span></span><br><span class="line">console.log(pattern2.ignoreCase);  <span class="comment">#true</span></span><br><span class="line">console.log(pattern2.lastIndex);  <span class="comment">#0</span></span><br><span class="line">console.log(pattern2.multiline);  <span class="comment">#false</span></span><br><span class="line">console.log(pattern2.source);    <span class="comment">#"\[bc]at"</span></span><br></pre></td></tr></table></figure>

<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。返回的数组包含两个额外的属性：<br>index与input属性，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有匹配组，则该数组只包含一项）<br>实例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line">var pattern = /mom(and dad(and baby)?)?/gi;</span><br><span class="line">var matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line">console.log(matches.index);    <span class="comment"># 0 与整个模式匹配的字符串的第一项的位置</span></span><br><span class="line">console.log(matches.input);    <span class="comment"># "mom and dad and baby" 与整个模式匹配的字符串</span></span><br><span class="line">console.log(matches[0]);       <span class="comment"># "mom and dad and baby" 整个字符串本身的匹配项</span></span><br><span class="line">console.log(matches[1]);       <span class="comment"># "and dad and baby"    与第一个捕获组匹配的内容</span></span><br><span class="line">console.log(matches[2]);       <span class="comment"># "and baby"    与第二个捕获组匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项，在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。如下面例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="comment"># 非全局模式下：</span></span><br><span class="line">var pattern1 = /.at/;</span><br><span class="line">var matches = pattern1.exec[text];</span><br><span class="line">console.log(matches.index);   <span class="comment">#0</span></span><br><span class="line">console.log(matches[0]);    <span class="comment">#cat</span></span><br><span class="line">console.log(pattern1.lastIndex);   <span class="comment">#0</span></span><br><span class="line"><span class="comment"># 每次调用exec()返回的都是第一个匹配项("cat")</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line">console.log(matches.index);   <span class="comment">#0</span></span><br><span class="line">console.log(matches[0]);    <span class="comment">#cat</span></span><br><span class="line">console.log(pattern1.lastIndex);   <span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">var pattern2 = /.at/g;</span><br><span class="line">var matches = pattern2.exec[text];</span><br><span class="line">console.log(matches.index);   <span class="comment">#0</span></span><br><span class="line">console.log(matches[0]);    <span class="comment">#cat</span></span><br><span class="line">console.log(pattern2.lastIndex);   <span class="comment">#4</span></span><br><span class="line"><span class="comment"># 每次调用exec()返回的都是下一个匹配项，直到搜索到字符串末尾为止</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line">console.log(matches.index);   <span class="comment">#0</span></span><br><span class="line">console.log(matches[0]);    <span class="comment">#bat</span></span><br><span class="line">console.log(pattern2.lastIndex);   <span class="comment">#8</span></span><br></pre></td></tr></table></figure>

<p>正则表达式的第二个方法是test(),它接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便，因此test()方法经常被用在if语句中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"000-00-0000"</span>;</span><br><span class="line">var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    console.log(<span class="string">"这个模式有匹配项"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化，并且这些属性可以以两种方式访问，下表列出了RegExp构造函数的一些属性</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串，Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项，Opera未实现此功能</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组，Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>mulitiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都是使用多行模式，IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>input字符串中lastMatch之后的文本</td>
</tr>
</tbody></table>
<p>使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息，例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line">var pattern = /(.)hort/g;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    console.log(RegExp.input);        <span class="comment">#this has been a short summer</span></span><br><span class="line">    console.log(RegExp.lastMatch);    <span class="comment">#short</span></span><br><span class="line">    console.log(RegExp.leftContext);  <span class="comment">#this has been a</span></span><br><span class="line">    console.log(RegExp.rightContext); <span class="comment">#summer</span></span><br><span class="line">    console.log(RegExp.mulitiline);   <span class="comment">#false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过短属性来访问它们，这里就不介绍了，与长属性用法相同</p>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性，访问这些属性的方法是RegExp.$1、RegExp.$2 … RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组，在调用exec()或test()方法时，这些属性会被自动填充，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"this has been a short summer"</span></span><br><span class="line">var pattern = /(..)or(.)/g;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    console.log(RegExp.<span class="variable">$1</span>);   <span class="comment">#sh</span></span><br><span class="line">    console.log(RegExp.<span class="variable">$2</span>);   <span class="comment">#t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>函数是对象，函数名是一个指向函数对象的指针，不会与某个函数绑定，函数声明定义形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum (num1,num2)&#123;</span><br><span class="line">    <span class="built_in">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addSomeNumber(num) &#123;</span><br><span class="line">    reurn num +100;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> addSomeNumber(num) &#123;</span><br><span class="line">    reurn num +200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = addSomeNumber(100);  <span class="comment">#300</span></span><br></pre></td></tr></table></figure>

<p>第二个函数覆盖了第一个函数的变量，函数没有重载</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，会先读取函数声明，并使其在执行任何代码之前可用（可以访问），而函数表达式是等到解析器执行到它所在的代码行，才会真正被解释执行。<br>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(20,20));</span><br><span class="line"><span class="keyword">function</span> sum(num1,num2)&#123;</span><br><span class="line">    <span class="built_in">return</span> num1 +num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析器通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中，就是sum函数已经提前声明，所以可以在前面调用</p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> callSomeFunction(someFunction, someArgument)&#123;</span><br><span class="line">    <span class="built_in">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有3个特殊的对象：arguments、this和caller。<br>arguments是一个类数组对象，包含着传入函数中的所有参数，除此之外arguments还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数；<br>如下递归阶乘函数所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> factorial(num) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=1) &#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> num*arguments.callee(num-1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this引用的是函数执行的环境对象，在全局作用域中，this对象引用的是window。比如下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = <span class="string">"red"</span>;</span><br><span class="line">var o = &#123;color: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayColor</span></span>() &#123;</span><br><span class="line">    console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();    <span class="comment">#"red"</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">#"blue"</span></span><br></pre></td></tr></table></figure>

<p>第一次调用sayColor()是在全局作用域中定义的，this引用的对象是window，所以输出为”red”, 第二次this引用的对象是0，所以this.color= o.color, 返回为”blue”<br>caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，会为null。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outer</span></span>() &#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">inner</span></span>() &#123;</span><br><span class="line">    console.log(arguments.calle.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>由于ECMAScript中的函数是对象，所以函数也有属性和方法，每个函数有两个属性：length和prototype<br>length表示函数希望接收的命名参数的个数，prototype指的函数的原型方法，toString()、valueOf()等都属于prototype内。<br>每个函数也会包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，其中，第二个参数可以是Array的实例，也可以是arguments对象。<br>如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(num1,num2) &#123;</span><br><span class="line">    <span class="built_in">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> callSum1(num1,num2) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum.apply(this,arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> callSum2(num1,num2) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum.apply(this,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(callSum1(10,10))   <span class="comment">#20</span></span><br><span class="line">console.log(callSum2(10,10))   <span class="comment">#20</span></span><br></pre></td></tr></table></figure>

<p>call()与apply()的作用没有什么不同，只是call()必须将传递给函数的参数逐个列举出来，如下面例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sum(num1,num2) &#123;</span><br><span class="line">    <span class="built_in">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> callSum(num1,num2) &#123;</span><br><span class="line">    <span class="built_in">return</span> sum.call(this,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(callSum(10,10))   <span class="comment">#20</span></span><br></pre></td></tr></table></figure>

<p>传递参数并非apply()和call()的真正用武之地，它们真正强大的地方是能扩充函数赖以运行的作用域，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = <span class="string">"red"</span>;</span><br><span class="line">var o = &#123;color: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayColor</span></span>() &#123;</span><br><span class="line">    console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor.call(this);     <span class="comment">#"red"</span></span><br><span class="line">sayColor.call(window);   <span class="comment">#"red"</span></span><br><span class="line">sayColor.call(o);        <span class="comment">#"blue"</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript5还定义了一个方法：bind(),这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = <span class="string">"red"</span>;</span><br><span class="line">var o = &#123;color: <span class="string">"blue"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sayColor</span></span>() &#123;</span><br><span class="line">    console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();    <span class="comment">#"blue"</span></span><br></pre></td></tr></table></figure>

<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt()与chaeCodeAt()方法，这两个方法都接收一个参数，即基于0的字符位置，charAt()方法以单字符串的形式返回给定位置的那个字符，chaeCodeAt()返回的是给定位置的字符编码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"hello world"</span>；</span><br><span class="line">console.log(stringValue.charAt(1));      <span class="comment">#"e"</span></span><br><span class="line">console.log(stringValue.与chaeCodeAt(1));  <span class="comment">#"101"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>concat()：用于将一或多个字符串拼接起来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"hello "</span>;</span><br><span class="line">var result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line">console.log(result);         <span class="comment">#"hello world!"</span></span><br><span class="line">console.log(stringValue)     <span class="comment">#"hello "</span></span><br></pre></td></tr></table></figure>

<p>创建新字符串的三种方法：都接受一到两个参数<br>slice()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substring()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substr()： ：第一个参数用于指定字符串的开始位置，第二个参数表示返回的字符个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"hello world"</span>;</span><br><span class="line">console.log(stringValue.slice(3));           <span class="comment">#"lo world"</span></span><br><span class="line">console.log(stringValue.substring(3));       <span class="comment">#"lo world"</span></span><br><span class="line">console.log(stringValue.substr(3));          <span class="comment">#"lo world"</span></span><br><span class="line"></span><br><span class="line">console.log(stringValue.slice(3,7));           <span class="comment">#"lo w"</span></span><br><span class="line">console.log(stringValue.substring(3,7));       <span class="comment">#"lo w"</span></span><br><span class="line">console.log(stringValue.substr(3,7));          <span class="comment">#"lo worl"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()，这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该字符串，则返回-1），indexOf()方法是从字符串的开头向后搜索子字符串，而和lastIndexOf()方法是从字符串的末尾向前搜索子字符串。同时这两个方法都可以接收第二个参数，表示从字符串的哪个位置开始搜索。因此可以通过循环调用indexOf()和lastIndexOf()来找到所有匹配的子字符串。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"hello world,helo,dsjfkgsdlfkglfd"</span>;</span><br><span class="line">var positions = new Array();</span><br><span class="line">var pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(pos&gt;-1)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos+1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(positions);   <span class="comment">#[ 1, 13 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h3><p>trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"  hello world   "</span>;</span><br><span class="line">var trimstringValue = stringValue.trim();</span><br><span class="line">console.log(trimstringValue);  <span class="comment">#"hello world"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>字符串大小写转换方法有toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。<br>toLowerCase()与toUpperCase()是通用方法，toLocaleLowerCase()与toLocaleUpperCase()是针对特定地区的实现，一般来说不知道自己的代码将在哪种语言运行环境下运行的时候，还是使用针对地区的方法更稳妥一些，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"Hello World"</span></span><br><span class="line">console.log(stringValue.toLowerCase());</span><br><span class="line">console.log(stringValue.toLocaleLowerCase());</span><br><span class="line">console.log(stringValue.toUpperCase());</span><br><span class="line">console.log(stringValue.toLocaleUpperCase());</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><p>match(): 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象。<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line">var pattern = /.at/;</span><br><span class="line">var matches = text.match(pattern);</span><br><span class="line">console.log(matches.index);   <span class="comment">#0</span></span><br><span class="line">console.log(matches[0]);    <span class="comment">#cat</span></span><br><span class="line">console.log(pattern.lastIndex);   <span class="comment">#0</span></span><br></pre></td></tr></table></figure>

<p>search()：这个方法返回字符串中的第一个匹配项的索引，如果没有找到匹配项，则返回-1，这个方法的唯一参数与match()方法相同。<br>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"hello,bat,sat,fat"</span></span><br><span class="line">var pattern = /.at/;</span><br><span class="line">var pos = text.search(pattern);</span><br><span class="line">console.log(pos);   <span class="comment">#6</span></span><br></pre></td></tr></table></figure>

<p>replace()方法：这个方法接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的方法就是提供一个正则表达式，而且要指定全局（g）标志。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line">var result = text.replace(/at/g,<span class="string">"12"</span>);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c12,b12,s12,f12</span><br></pre></td></tr></table></figure>

<p>replace()方法的第二个参数也可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> himlEscape(text) &#123;</span><br><span class="line">    <span class="built_in">return</span> text.replace(/[&lt;&gt;<span class="string">"&amp;]/g, function(match,pos,originalText)&#123;</span></span><br><span class="line"><span class="string">        switch(match) &#123;</span></span><br><span class="line"><span class="string">            case "</span>&lt;<span class="string">":</span></span><br><span class="line"><span class="string">                return "</span>&amp;lt;<span class="string">";</span></span><br><span class="line"><span class="string">            case "</span>&gt;<span class="string">":</span></span><br><span class="line"><span class="string">                return "</span>&amp;gt;<span class="string">";</span></span><br><span class="line"><span class="string">            case "</span>&amp;<span class="string">":</span></span><br><span class="line"><span class="string">                return "</span>&amp;amp;<span class="string">";</span></span><br><span class="line"><span class="string">            case "</span>\<span class="string">""</span>:</span><br><span class="line">                <span class="built_in">return</span> <span class="string">"&amp;quot"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(himlEscape(<span class="string">"&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"</span>));  <span class="comment">#&amp;lt;p class=&amp;quotgreeting&amp;quot&amp;gt;Hello World!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>

<p>split()方法：这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会讲字符串看成正则表达式），split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回额数组不会超过既定大小。如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line">var color = colorText.split(<span class="string">","</span>);</span><br><span class="line">console.log(color);                <span class="comment">#["red","blue","green","yellow"]</span></span><br></pre></td></tr></table></figure>

<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h3><p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：<br>1、如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况是-1）；<br>2、如果字符串等于字符串参数，则返回0；<br>3、如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"yellow"</span>;</span><br><span class="line">console.log(stringValue.localeCompare(<span class="string">"black"</span>)); <span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h3><p>接收一或多个字符编码，将它们转换为字符串。示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(String.fromCharCode(104,101,108,108,111));   <span class="comment">#"hello"</span></span><br></pre></td></tr></table></figure>

<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>所有在全局作用域中定义的属性和方法都是Global对象的属性。除了isNaN()、isFinite()、parseInt()、parseFloat()等方法之外，Global对象还包含其他一些方法<br>这里主要介绍常用的eval()方法，eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'"</span>);</span><br><span class="line">console.log(msg);    <span class="comment">#hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h3 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底的e对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底的e对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>Π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根</td>
</tr>
<tr>
<td>Math.SQRt2</td>
<td>2的平方根</td>
</tr>
</tbody></table>
<h3 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h3><p>min()、max()方法用于确定一组数值中的最小最大值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var max = Math.max(3,56,89,74,51,65,12);</span><br><span class="line">console.log(max);     <span class="comment">#89</span></span><br><span class="line">var min = Math.min(3,56,89,74,51,65,12);</span><br><span class="line">console.log(min);    <span class="comment">#3</span></span><br></pre></td></tr></table></figure>

<p>舍入方法：Math.ceil()、Math.floor()、Math.round()<br>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。</p>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h3><p>Math.random()方法返回介于1到1之间的一个随机数，不包括0和1</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.abs(num)</td>
<td>返回num的绝对值</td>
<td>Math.asin(x)</td>
<td>返回x的反正弦值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E的num次幂</td>
<td>Math.atan(x)</td>
<td>返回x的反正切值</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num的自然对数</td>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切值</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num的power次幂</td>
<td>Math.cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num的平方根</td>
<td>Math.sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦值</td>
<td>Math.tan(x)</td>
<td>返回x的正切值</td>
</tr>
</tbody></table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/7.html" class="post-title-link" itemprop="url">第四章 变量、作用域和内存问题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 21:09:15" itemprop="dateCreated datePublished" datetime="2019-08-12T21:09:15+08:00">2019-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 15:41:31" itemprop="dateModified" datetime="2019-08-30T15:41:31+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/JavaScript高级程序设计/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript变量可能包含不同数据类型的值：基本类型值和引用类型值。<br>基本类型值：指的是简单的数据段，Undefined、Null、Boolean、Number和String这五种基本数据类型是按值访问的。<br>引用类型值：指的是那些可能由多个值构成的对象，引用类型的值是保存在内存中的对象。<br>与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>引用类型的值可以动态地添加属性和方法，也可以改变和删除其属性和方法，但是不能给基本类型的值添加属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 为引用类型的值添加属性并给属性赋值</span><br><span class="line">var person = new Object();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">console.log(person.name);  // <span class="string">"Nicholas"</span></span><br><span class="line"></span><br><span class="line">//为基本类型的值添加属性会返回undefined,但是不会报错</span><br><span class="line">var name = <span class="string">"Nicholas"</span>;</span><br><span class="line">name.age = 27;</span><br><span class="line">console.log(name.age);  // undefined</span><br></pre></td></tr></table></figure>

<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>基本类型值与引用类型值复制变量是不同的。<br>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个变量可以参与任何操作而不会相互影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 5;</span><br><span class="line">var num2 = num1;  // num1与num2的值都是5，但是他们两个相互之间没有影响</span><br></pre></td></tr></table></figure>

<p>如果一个变量向另一个变量复制引用类型的值，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制结束后，两个变量实际上将引用同一个对象，改变一个变量，就会影响另一个变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = new Object();</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">console.log(obj2.name); // <span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数），<br>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addTen(num) &#123;</span><br><span class="line">    num += 10;</span><br><span class="line">    <span class="built_in">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line">var count = 20;</span><br><span class="line">var result = addTen(count);</span><br><span class="line">console.log(count);  // 20</span><br><span class="line">console.log(result);  // 30</span><br></pre></td></tr></table></figure>

<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>typeof 可以检测基本数据类型，instanceof可以检测引用数据类型。<br>根据规定，所有引用类型的值都是Object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true，<br>使用instanceof操作符检测基本类型的值，则该操作符始终会返回false。</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有便俩个和函数定义也随之销毁。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在一开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。<br>作用域链中的下一个变量对象包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境，全局执行环境中的变量对象始终都是作用域链中的最后一个对象。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">changeColor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(color == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color == <span class="string">"grey"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br><span class="line">console.log(<span class="string">"Color is "</span> + color);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color is red</span><br></pre></td></tr></table></figure>

<p>上面例子中的函数changColor()的作用域链的中包含两个对象，它自己的变量对象（其中定义着arguments）和全局环境的变量对象。<br>作用域链为它自己的变量对象 ——&gt; 全局环境的变量对象</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，在两种情况下会发生这种现象，出现以下两种现象时，执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li>try-catch 语句的 catch 块；</li>
<li>with 语句。</li>
</ul>
<p>这两个语句都会在作用域的前端添加一个变量对象，对with语句来说，会将指定的对象添加到作用域链中；<br>对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。<br>如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">buildUrl</span></span> () &#123;</span><br><span class="line">    var qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    with(location)[</span><br><span class="line">        var url = href + qs;</span><br><span class="line">    ]</span><br><span class="line">    <span class="built_in">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加进了作用域链的前端，buildUrl()函数中定义了一个变量qs，当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到，当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中，因此with内部的url就成了函数执行环境的一部分，可以作为函数的值返回。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>JavaScript没有块级作用域，在其他类C的语言中，由花括号封闭的代码都有自己的作用域（用ECMAScript的话来说就是他们自己的执行环境）。<br>因而支持根据条件来定义变量，例如，下面的代码在JavaScript中并不会得到想象中的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    var color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line">console.log(color); //<span class="string">"blue"</span></span><br></pre></td></tr></table></figure>

<p>这个例子，如果是在C、C++或Java中，color会在if语句执行完毕后被销毁，但是在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。<br>使用for语句时也会发生这样的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var i=0; i&lt;10;i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);  // 10</span><br></pre></td></tr></table></figure>

<p>for循环执行结束后，由for语句创建的i依旧存在于循环外部的执行环境中。<br><strong>解决这种办法ES6使用let声明变量，用let声明可以将作用域限制在当前块中。</strong><br><strong>声明变量：</strong>使用var声明的变量会自动被添加进最接近的环境中，在函数内部，最接近的环境就是函数的局部环境，在with语句中，最接近的环境是函数环境，如果初始化变量时没有使用var声明，该变量会自动添加进全局环境。<br><strong>查询标识符：</strong>搜索过程从作用域链的前端开始，向上逐级查询给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪；如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索，搜索过程一直追溯到全局环境的变量对象，如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JavaScript具有自动垃圾收集机制，垃圾收集器跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，用于标识无用变量的策略主要有以下两种办法：<br>标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去除环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br>引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1；相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/6.html" class="post-title-link" itemprop="url">面向对象高级编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 16:53:24" itemprop="dateCreated datePublished" datetime="2019-08-12T16:53:24+08:00">2019-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 15:41:01" itemprop="dateModified" datetime="2019-08-30T15:41:01+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/Python-知识汇总/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能，我们会讨论多重继承、定制类、元类等概念。</p>
<h2 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h2><p><strong>slots</strong>是用来限制class实例能添加的属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure>

<p>测试结果L:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line">&gt;&gt;&gt; s.name = <span class="string">'Michael'</span> <span class="comment"># 绑定属性'name'</span></span><br><span class="line">&gt;&gt;&gt; s.age = 25 <span class="comment"># 绑定属性'age'</span></span><br><span class="line">&gt;&gt;&gt; s.score = 99 <span class="comment"># 绑定属性'score'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></span><br></pre></td></tr></table></figure>

<p><strong>由于’score’没有被放到<strong>slots</strong>中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</strong></p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>在绑定属性时，如果我们直接向下面这样把属性暴露出去，虽然写起来简单，但是，没办法检查参数，导致成绩可以随便改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = 9999</span><br></pre></td></tr></table></figure>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">         <span class="built_in">return</span> self._score</span><br><span class="line"></span><br><span class="line">    def set_score(self, value):</span><br><span class="line">        <span class="keyword">if</span> not isinstance(value, int):</span><br><span class="line">            raise ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.set_score(60) <span class="comment"># ok!</span></span><br><span class="line">&gt;&gt;&gt; s.get_score()</span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.set_score(9999)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure>

<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。<br>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！<br>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        <span class="built_in">return</span> self._score</span><br><span class="line"></span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        <span class="keyword">if</span> not isinstance(value, int):</span><br><span class="line">            raise ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student()</span><br><span class="line">&gt;&gt;&gt; s.score = 60 <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line">&gt;&gt;&gt; s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line">60</span><br><span class="line">&gt;&gt;&gt; s.score = 9999</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between 0 ~ 100!</span><br></pre></td></tr></table></figure>

<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。<br>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        <span class="built_in">return</span> self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        <span class="built_in">return</span> 2015 - self._birth</span><br></pre></td></tr></table></figure>

<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。<br><strong>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</strong></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能，例如Animal类层的设计，假设我们要实现以下4种动物：</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。<br>如果按照哺乳动物与鸟类归类，可以将Dog与Bat归为一类，Parrot与Ostrich归为一类，但是如果我们再按照能跑与能飞来分类，将非常麻烦，所以python设计多重继承</li>
</ul>
<p>我们要给动物加上Runable与Flyable的功能，只需要定义好Runnable与Flyable的类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Runnable(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Running...'</span>)</span><br><span class="line"></span><br><span class="line">class Flyable(object):</span><br><span class="line">    def fly(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Flying...'</span>)</span><br></pre></td></tr></table></figure>

<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, Runnable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Bat(Mammal, Flyable):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。<br>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyTCPServer(TCPServer, ForkingMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>编写一个多线程模式的UDP服务，定义如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyUDPServer(UDPServer, ThreadingMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyTCPServer(TCPServer, CoroutineMixIn):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br><strong>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。只允许单一继承的语言（如Java）不能使用MixIn的设计。</strong></p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p><strong>str</strong><br>我们先定义一个Student类，打印一个实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(Student(<span class="string">'Michael'</span>))</span><br><span class="line">&lt;__main__.Student object at 0x109afb190&gt;</span><br></pre></td></tr></table></figure>

<p>打印出一堆&lt;<strong>main</strong>.Student object at 0x109afb190&gt;，不好看。<br>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...         <span class="built_in">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure>

<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student(<span class="string">'Michael'</span>)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&lt;__main__.Student object at 0x109afb310&gt;</span><br></pre></td></tr></table></figure>

<p>这是因为直接显示变量调用的不是<strong>str</strong>()，而是<strong>repr</strong>()，两者的区别是<strong>str</strong>()返回用户看到的字符串，而<strong>repr</strong>()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。</p>
<p>解决办法是再定义一个<strong>repr</strong>()。但是通常<strong>str</strong>()和<strong>repr</strong>()代码都是一样的，所以，有个偷懒的写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        <span class="built_in">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; 100000: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            raise StopIteration()</span><br><span class="line">        <span class="built_in">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>

<p>现在，试试把Fib实例作用于for循环：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line">...     <span class="built_in">print</span>(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">...</span><br><span class="line">46368</span><br><span class="line">75025</span><br></pre></td></tr></table></figure>

<h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Fib()[5]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'Fib'</span> object does not support indexing</span><br></pre></td></tr></table></figure>

<p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        a, b = 1, 1</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="built_in">return</span> a</span><br></pre></td></tr></table></figure>

<p>现在，就可以按下标访问数列的任意一项了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = Fib()</span><br><span class="line">&gt;&gt;&gt; f[0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f[1]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f[2]</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; f[3]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; f[10]</span><br><span class="line">89</span><br><span class="line">&gt;&gt;&gt; f[100]</span><br><span class="line">573147844013817084101</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/5.html" class="post-title-link" itemprop="url">面向对象编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 16:53:24" itemprop="dateCreated datePublished" datetime="2019-08-12T16:53:24+08:00">2019-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 15:40:56" itemprop="dateModified" datetime="2019-08-30T15:40:56+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/Python-知识汇总/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板，实例是根据类创建出来的一个个具体的“对象”。<br>以Student类为例，定义Student类，定义类的关键字是class</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。<br>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student()</span><br><span class="line">&gt;&gt;&gt; bart</span><br><span class="line">&lt;__main__.Student object at 0x10a67a590&gt;</span><br><span class="line">&gt;&gt;&gt; Student</span><br><span class="line">&lt;class <span class="string">'__main__.Student'</span>&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。<br>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<strong>init</strong>方法，在创建实例的时候，就把name，score等属性绑上去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure>

<p>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。<br>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(<span class="string">'Bart Simpson'</span>, 59)</span><br><span class="line">&gt;&gt;&gt; bart.name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br></pre></td></tr></table></figure>

<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>数据封装即是类的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lass Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    def print_score(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%s: %s'</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<p>在Student这个类中定义了print_score方法；和普通函数一样，要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart.print_score()</span><br><span class="line">Bart Simpson: 59</span><br></pre></td></tr></table></figure>

<p>练习1:在Student类里定义get_grade方法，成绩在90分以上返回这个人的名字和A，60到90之间为B，60以下为C</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    def get_grade(self):</span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= 90:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= 60:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> <span class="string">'C'</span></span><br><span class="line">lisa = Student(<span class="string">'Lisa'</span>, 99)</span><br><span class="line">bart = Student(<span class="string">'Bart'</span>, 59)</span><br><span class="line"><span class="built_in">print</span>(lisa.name, lisa.get_grade())</span><br><span class="line"><span class="built_in">print</span>(bart.name, bart.get_grade())</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lisa A </span><br><span class="line">Bart C</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；<br>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；<br>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。<br>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。<br>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart = Student(<span class="string">'Bart Simpson'</span>, 59)</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; bart.score = 99</span><br><span class="line">&gt;&gt;&gt; bart.score</span><br><span class="line">99</span><br></pre></td></tr></table></figure>

<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 __ ，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改,但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.__name = name         </span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    def get_name(self):      <span class="comment">#通过get_name获取内部名字等</span></span><br><span class="line">        <span class="built_in">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">        <span class="built_in">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    def set_score(self, score):   <span class="comment">#通过set_score修改内部变量，用这种办法，可以对参数进行检查，避免传入无效的参数</span></span><br><span class="line">        <span class="keyword">if</span> 0 &lt;= score &lt;= 100:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            raise ValueError(<span class="string">'bad score'</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。<br>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<strong>name是因为Python解释器对外把</strong>name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bart._Student__name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br></pre></td></tr></table></figure>

<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。<br>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。<br>练习2：请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, gender):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__gender = gender</span><br><span class="line">    def get_gender(self):</span><br><span class="line">        <span class="built_in">return</span> self.__gender</span><br><span class="line">    def set_gender(self,gender):</span><br><span class="line">        self.__gender = gender</span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">bart = Student(<span class="string">'Bart'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">if</span> bart.get_gender() != <span class="string">'male'</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bart.set_gender(<span class="string">'female'</span>)</span><br><span class="line">    <span class="keyword">if</span> bart.get_gender() != <span class="string">'female'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'测试成功!'</span>)</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试成功!</span><br></pre></td></tr></table></figure>

<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印，当我们需要编写Dog和Cat类时，就可以直接从Animal类继承</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Animal is running...'</span>)</span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。<br>继承就是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dog = Dog()</span><br><span class="line">&gt;&gt;&gt; dog.run()</span><br><span class="line">&gt;&gt;&gt; cat = Cat()</span><br><span class="line">&gt;&gt;&gt; cat.run()</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>

<p>不仅可以实现继承，同时子类可以对代码进行改进与修改</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Dog(Animal):</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;    def run(self):</span><br><span class="line">&gt;&gt;&gt;        <span class="built_in">print</span>(<span class="string">'Dog is running...'</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; class Cat(Animal):</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;     def run(self):</span><br><span class="line">&gt;&gt;&gt;        <span class="built_in">print</span>(<span class="string">'Cat is running...'</span>)</span><br><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>

<p><strong>子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run(),即继承的另一个好处：多态。</strong></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def run_twice(animal):</span><br><span class="line">&gt;&gt;&gt;    animal.run()</span><br><span class="line">&gt;&gt;&gt;    animal.run()</span><br><span class="line">&gt;&gt;&gt; run_twice(Animal())</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>

<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、还是Cat对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>对扩展开放：允许新增Animal子类；<br>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。<br>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树</p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><ul>
<li><p>1 基本类型可以用type()判断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(123)</span><br><span class="line">&lt;class <span class="string">'int'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(<span class="string">'str'</span>)</span><br><span class="line">&lt;class <span class="string">'str'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(None)</span><br><span class="line">&lt;<span class="built_in">type</span>(None) <span class="string">'NoneType'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 如果一个变量指向函数或者类，也可以用type()判断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(abs)</span><br><span class="line">&lt;class <span class="string">'builtin_function_or_method'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(a)</span><br><span class="line">&lt;class <span class="string">'__main__.Animal'</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 判断一个对象是否是函数可以使用types模块中定义的常量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(fn)==types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(abs)==types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(lambda x: x)==types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> range(10)))==types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说，使用types()就很不方便，为了判断class的类型，可以使用isinstance()函数:</p>
<ul>
<li>1 对于如下继承关系的函数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object -&gt; Animal -&gt; Dog -&gt; Husky</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>可以创建3种类型的对象，然后判断，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Animal()</span><br><span class="line">&gt;&gt;&gt; d = Dog()</span><br><span class="line">&gt;&gt;&gt; h = Husky()</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Husky)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(h, Dog)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(d, Husky)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<ul>
<li>2 可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>dir()函数可以获得一个对象的所有属性和方法，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(<span class="string">'ABC'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure>

<p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法，所以，下面的代码是等价的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(<span class="string">'ABC'</span>)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; <span class="string">'ABC'</span>.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyDog(object):</span><br><span class="line">...     def __len__(self):</span><br><span class="line">...         <span class="built_in">return</span> 100</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dog = MyDog()</span><br><span class="line">&gt;&gt;&gt; len(dog)</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyObject(object):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.x = 9</span><br><span class="line">...     def power(self):</span><br><span class="line">...         <span class="built_in">return</span> self.x * self.x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; obj = MyObject()</span><br><span class="line">&gt;&gt; hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; obj.x</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; setattr(obj, <span class="string">'y'</span>, 19) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line">&gt;&gt;&gt; hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; getattr(obj, <span class="string">'z'</span>) <span class="comment"># 获取属性'z',试图获取不存在的属性，会抛出AttributeError的错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'z'</span></span><br></pre></td></tr></table></figure>

<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; getattr(obj, <span class="string">'z'</span>, 404) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br><span class="line">404</span><br></pre></td></tr></table></figure>

<p>也可以获得对象的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line">&gt;&gt;&gt; fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line">81</span><br></pre></td></tr></table></figure>

<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>)</span><br><span class="line">s.score = 90</span><br></pre></td></tr></table></figure>

<p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = <span class="string">'Student'</span></span><br></pre></td></tr></table></figure>

<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     name = <span class="string">'Student'</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Student() <span class="comment"># 创建实例s</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line">&gt;&gt;&gt; del s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<p>练习:为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">class Student(object):</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += 1</span><br><span class="line">        <span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">if</span> Student.count != 0:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bart = Student(<span class="string">'Bart'</span>)</span><br><span class="line">    <span class="keyword">if</span> Student.count != 1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lisa = Student(<span class="string">'Bart'</span>)</span><br><span class="line">        <span class="keyword">if</span> Student.count != 2:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Students:'</span>, Student.count)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'测试通过!'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Students: 2 </span><br><span class="line">测试通过!</span><br></pre></td></tr></table></figure>

<p><strong>实例属性属于各个实例所有，互不干扰；类属性属于类所有，所有实例共享一个属性；不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</strong></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/4.html" class="post-title-link" itemprop="url">递归函数</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 16:53:24" itemprop="dateCreated datePublished" datetime="2019-08-12T16:53:24+08:00">2019-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 16:02:16" itemprop="dateModified" datetime="2019-08-30T16:02:16+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/Python-知识汇总/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>在函数内部，可以调用其他函数，如果一个函数在内部调用自身本身，这个函数就是递归函数<br>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：<br>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n<br>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。<br>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    <span class="keyword">if</span> n==1:</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="built_in">return</span> n * fact(n - 1)</span><br><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>递归函数的优点是定义简单，逻辑清晰，使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</p>
<h2 id="尾优化"><a href="#尾优化" class="headerlink" title="尾优化"></a>尾优化</h2><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以把循环看成一种特殊的尾递归函数也是可以的<br>尾递归是指，在函数返回的时候，调用自身本身，并且eturn语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。<br>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    <span class="built_in">return</span> fact_iter(n, 1)</span><br><span class="line"></span><br><span class="line">def fact_iter(num, product):</span><br><span class="line">    <span class="keyword">if</span> num == 1:</span><br><span class="line">        <span class="built_in">return</span> product</span><br><span class="line">    <span class="built_in">return</span> fact_iter(num - 1, num * product)</span><br></pre></td></tr></table></figure>

<p>可以看到，return fact_iter(num - 1, num * product) 仅返回递归函数本身，num - 1和 num * product在函数调用前就会被计算，不影响函数调用。<br>fact(5)对应的fact_iter(5, 1)的调用如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">===&gt; fact_iter(5, 1)</span><br><span class="line">===&gt; fact_iter(4, 5)</span><br><span class="line">===&gt; fact_iter(3, 20)</span><br><span class="line">===&gt; fact_iter(2, 60)</span><br><span class="line">===&gt; fact_iter(1, 120)</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。<br>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ningning666.github.io/Blog/Blog/posts/3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ningning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/Blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小怪兽成长记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Blog/posts/3.html" class="post-title-link" itemprop="url">函数式编程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-12 16:53:24" itemprop="dateCreated datePublished" datetime="2019-08-12T16:53:24+08:00">2019-08-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-30 16:05:16" itemprop="dateModified" datetime="2019-08-30T16:05:16+08:00">2019-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/Blog/categories/Python-知识汇总/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>python是面向对象编程的程序语言<br>函数就是面向过程的程序设计的基本单元。<br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，<br>因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。<br>而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><p>既可以将函数赋值结果给变量，也可以将函数本身赋值给变量，即变量可以指向函数<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = abs(-10)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; f=abs</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;built-in <span class="keyword">function</span> abs&gt;</span><br></pre></td></tr></table></figure>

<p>变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = abs</span><br><span class="line">&gt;&gt;&gt; f(-10)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    <span class="built_in">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>

<p><strong>编写高阶函数，就是让函数的参数能够接收别的函数。</strong></p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     <span class="built_in">return</span> x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">&gt;&gt;&gt; tuple(r)</span><br><span class="line">(1, 4, 9, 16, 25, 36, 49, 64, 81)</span><br></pre></td></tr></table></figure>

<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数或者tuple()函数让它把整个序列都计算出来并返回一个list<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>

<p>练习1: 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">&gt;&gt;&gt; def normalize(name):</span><br><span class="line">&gt;&gt;&gt;    <span class="built_in">return</span> name.capitalize()</span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 测试:</span></span><br><span class="line">&gt;&gt;&gt; L1 = [<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]</span><br><span class="line">&gt;&gt;&gt; L2 = list(map(normalize, L1))</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(L2)</span><br><span class="line">[<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>]</span><br></pre></td></tr></table></figure>

<p>练习2: Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def prod(L):</span><br><span class="line">&gt;&gt;&gt;   <span class="built_in">return</span> reduce(lambda x, y: x * y, L)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">'3 * 5 * 7 * 9 ='</span>, prod([3, 5, 7, 9]))</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> prod([3, 5, 7, 9]) == 945:</span><br><span class="line">&gt;&gt;&gt;   <span class="built_in">print</span>(<span class="string">'测试成功!'</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">else</span>:</span><br><span class="line">&gt;&gt;&gt;    <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line">3 * 5 * 7 * 9 = 945</span><br><span class="line">测试成功!</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的filter()函数用于过滤序列,用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。<br>filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list.<br>示例如下：<br>用filter求素数<br>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：<br>首先，列出从2开始的所有自然数，构造一个序列：<br>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：<br>3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：<br>5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取新序列的第一个数5，然后用5把序列的5的倍数筛掉：<br>7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>不断筛下去，就可以得到所有的素数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用Python来实现这个算法，可以先构造一个从3开始的奇数序列：</span></span><br><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line"><span class="comment"># 然后定义一个筛选函数：</span></span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    <span class="built_in">return</span> lambda x: x % n &gt; 0</span><br><span class="line"><span class="comment"># 最后，定义一个生成器，不断返回下一个素数：</span></span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="comment">#由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：</span></span><br><span class="line"><span class="comment"># 打印1000以内的素数:</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; 1000:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br></pre></td></tr></table></figure>

<p>练习3: 回数是指从左向右读和从右向左读都是一样的数，例如 12321 ， 909 。请利用 filter() 滤掉非回数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方案一:</span><br><span class="line">def is_palindrome(n):</span><br><span class="line">    nn = str(n) <span class="comment">#转成字符串</span></span><br><span class="line">    <span class="built_in">return</span> nn == nn[::-1]   <span class="comment">#反转字符串并对比原字符串返回true/false</span></span><br><span class="line"><span class="built_in">print</span> list(filter(is_palindrome,range(1,1000)))</span><br><span class="line"></span><br><span class="line">方案二:</span><br><span class="line"><span class="built_in">print</span> list(filter(lambda n : str(n)==str(n)[::-1],range(1,1000))) <span class="comment">#str(n)同上</span></span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted()也是一个高阶函数，用sorted()排序的关键在于实现一个映射函数<br>练习4：假设我们用一组tuple表示学生名字和成绩：L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]<br>请用sorted()对上述列表分别按名字排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">L = [(<span class="string">'Bob'</span>, 75), (<span class="string">'Adam'</span>, 92), (<span class="string">'Bart'</span>, 66), (<span class="string">'Lisa'</span>, 88)]</span><br><span class="line">def by_name(t):</span><br><span class="line">    <span class="built_in">return</span> t[0].lower()</span><br><span class="line">L2 = sorted(L, key=by_name)</span><br><span class="line"><span class="built_in">print</span>(L2)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'Adam'</span>, 92), (<span class="string">'Bart'</span>, 66), (<span class="string">'Bob'</span>, 75), (<span class="string">'Lisa'</span>, 88)]</span><br></pre></td></tr></table></figure>

<p>再按成绩从高到低排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">L = [(<span class="string">'Bob'</span>, 75), (<span class="string">'Adam'</span>, 92), (<span class="string">'Bart'</span>, 66), (<span class="string">'Lisa'</span>, 88)]</span><br><span class="line">def by_score(t):</span><br><span class="line">    <span class="built_in">return</span> t[1]</span><br><span class="line">L2 = sorted(L, key=by_score)</span><br><span class="line"><span class="built_in">print</span>(L2)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="string">'Bart'</span>, 66), (<span class="string">'Bob'</span>, 75), (<span class="string">'Lisa'</span>, 88), (<span class="string">'Adam'</span>, 92)]</span><br></pre></td></tr></table></figure>

<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def lazy_sum(*args):</span><br><span class="line">&gt;&gt;&gt;     def sum():</span><br><span class="line">&gt;&gt;&gt;        ax = 0</span><br><span class="line">&gt;&gt;&gt;        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">&gt;&gt;&gt;            ax = ax + n</span><br><span class="line">&gt;&gt;&gt;        <span class="built_in">return</span> ax</span><br><span class="line">&gt;&gt;&gt;    <span class="built_in">return</span> sum</span><br><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)  <span class="comment">#当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数</span></span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;<span class="keyword">function</span> lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br><span class="line">&gt;&gt;&gt; f()                 <span class="comment">#调用函数f时，才真正计算求和的结果</span></span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f1==f2              <span class="comment">#f1()和f2()的调用结果互不影响。</span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。<br>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             <span class="built_in">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="built_in">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。<br><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>练习5：利用闭包返回一个计数器函数，每次调用它返回递增整数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">def createCounter():</span><br><span class="line">    s = [0]</span><br><span class="line">    def counter():</span><br><span class="line">        s[0] = s[0]+1</span><br><span class="line">        <span class="built_in">return</span> s[0]</span><br><span class="line">    <span class="built_in">return</span> counter</span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">counterA = createCounter()</span><br><span class="line"><span class="built_in">print</span>(counterA(), counterA(), counterA(), counterA(), counterA()) <span class="comment"># 1 2 3 4 5</span></span><br><span class="line">counterB = createCounter()</span><br><span class="line"><span class="keyword">if</span> [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'测试通过!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'测试失败!'</span>)</span><br><span class="line">1 2 3 4 5</span><br><span class="line">测试通过!</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。<br>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;<span class="keyword">function</span> &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">'2015-3-25'</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = now        <span class="comment">#由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</span></span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">2015-3-25</span><br><span class="line">&gt;&gt;&gt; now.__name__   <span class="comment">#函数对象有一个__name__属性，可以拿到函数的名字</span></span><br><span class="line"><span class="string">'now'</span></span><br><span class="line">&gt;&gt;&gt; f.__name__</span><br><span class="line"><span class="string">'now'</span></span><br></pre></td></tr></table></figure>

<p>假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br>简单例子如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def <span class="built_in">log</span>(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="built_in">return</span> func(*args, **kw)</span><br><span class="line">        <span class="built_in">return</span> wrapper</span><br><span class="line">    <span class="built_in">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>具体见廖雪峰学习网站，这里不具体介绍装饰器</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/Blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/Blog/page/3/">3</a><a class="extend next" rel="next" href="/Blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ningning</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/Blog/archives">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/Blog/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/Blog/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ningning</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/Blog/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/Blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/Blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/Blog/js/utils.js?v=7.1.2"></script>

  <script src="/Blog/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/Blog/js/affix.js?v=7.1.2"></script>

  <script src="/Blog/js/schemes/pisces.js?v=7.1.2"></script>




  

  


  <script src="/Blog/js/next-boot.js?v=7.1.2"></script>


  

  

  

  



  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/Blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
