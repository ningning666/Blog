<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise与异步编程]]></title>
    <url>%2FBlog%2Fposts%2F25.html</url>
    <content type="text"></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript专项练习1]]></title>
    <url>%2FBlog%2Fposts%2F24.html</url>
    <content type="text"><![CDATA[JavaScript-打开新窗口（window.open）open() 方法可以查找一个已经存在或者新建的浏览器窗口。 语法：window.open([URL], [窗口名称], [参数字符串])参数说明： URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 该名称由字母、数字和下划线字符组成。 “_top”、”_blank”、”_self”具有特殊意义的名称。其中： “_blank”：在新窗口显示目标网页 “_self”：在当前窗口显示目标网页 “_top”：框架网页中在上部窗口中显示目标网页 相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 name 不能包含有空格。例题如下所示： 12//打开名为 "window2" 的新窗口的 JavaScript 语法是？window.open("http://www.w3school.com.cn","window2") JavaScript setTimeout() 用法详解setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout(() =&gt; {}), 0) 用例是调用一个函数，会在代码中其他每个函数都已执行后再执行它。语法格式可以是以下两种： 12setTimeout(要执行的代码, 等待的毫秒数)setTimeout(JavaScript 函数, 等待的毫秒数) 提示： 1000 毫秒= 1 秒。提示： 如果你只想重复执行可以使用 setInterval() 方法。使用setInterval()时的阻止方法是clearInterval()。提示： 使用 clearTimeout() 方法来阻止函数的执行。 例题如下所示： 12345678// 以下语句的执行结果是什么？console.log('one');setTimeOut(function() &#123; console.log('two');&#125;, 0);console.log('three');// 输出结果：'one','three','two' js如何判断一个对象是不是Array在说明如何判断一个对象为数组类型前，我们先巩固下js的数据类型，js一共有六大数据类型：number、string、object、Boolean、null、undefined。 string： 由单引号或双引号来说明，如”string”； number：数组类型，比如整数、小数等； Boolean: 有两个值：true、false; undefined：未定义，就是你创建一个变量后却没给它赋值； null: 顾名思义，null就是没有，什么也不表示； object: 除了上面五种之外的类型。 js的数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素可以是对象或其他数组，这样就可以创建复杂的数据结构。通常我们可以用一元运算符typeof来判断js的数据类型，但是对于数组这样一个特殊的对象却只能返回”object”。typeof可以解决大部分的数据类型判断，是一个一元运算，放在一个运算值之前，其返回值为一个字符串，该字符串说明运算数的类型，所以判断某个是否为String类型，可以直接 if(typeof(你的值) == “string”){}。除了前四个类型外，null、对象、数组返回的都是object类型；对于函数类型返回的则是function，再比如typeof(Date)，typeof(eval)等。js判断数组类型的方法有下面四种： instance操作符instanceof 用于判断一个变量是否某个对象的实例，左边操作数是一个对象，右边操作数是一个函数对象或者函数构造器。原理是通过判断左操作数的对象的原型链上是否具有右操作数的构造函数的prototype属性。但是对于instanceof和多全局对象（多个frame或多个window之间的交互），即在浏览器中，我们的脚本需要在多个窗口之间进行交互，多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数，这可能会引发一些问题，比如：表达式[] instanceof window.frames[0].Array会返回false，因为Array.prototype !== window.frames[0].Array.prototype。 Array.isArray(myObj)方法数组自身判断的方法。 constructor在W3C定义中的定义：constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。从定义上来说跟instanceof不太一致，但效果都是一样的。 Object.prototype.toString.call(arr) === “[object Array]”这是最简单的方法。与 Array.isArray(myObj)一样能准确判断数组。 对象转布尔值情况任何兑现转为布尔值，都得到true，切记在JS 中，只有0，-0，NaN,””, null，undefined这六个值转布尔值时，结果为false。例题如下： 12345678var x = new Boolean(false);if (x) &#123; alert('hi');&#125;var y = Boolean(0);if (y) &#123; alert('hello'); &#125; 结果为&#39;hi&#39; 原型继承试题试题如下所示： 123456Function.prototype.a = 'a';Object.prototype.b = 'b';function Person()&#123;&#125;;var p = new Person();console.log('p.a: '+ p.a); # p.a: undefinedconsole.log('p.b: '+ p.b); # p.b: b 问为什么？ Person函数才是Function对象的一个实例，所以通过Person.a可以访问到Function原型里面的属性，但是new Person()返回来的是一个对象，它是Object的一个实例,是没有继承Function的，所以无法访问Function原型里面的属性。但是,由于在js里面所有对象都是Object的实例，所以，Person函数可以访问到Object原型里面的属性，Person.b =&gt; &#39;b&#39;]]></content>
      <categories>
        <category>计算机~JavaScript专项练习</category>
      </categories>
      <tags>
        <tag>计算机~JavaScript专项练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2FBlog%2Fposts%2F15.html</url>
    <content type="text"><![CDATA[栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。 对栈的操作栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。栈被称为一种后入先出的数据结构。栈的两种操作：入栈 push() 方法，出栈 pop() 方法。另一个常用的操作是预览栈顶的元素。pop() 方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。peek() 方法则只返回栈顶元素，而不删除它。其它属性与方法： clear() 方法清除栈内所有元素；length 属性记录栈内元素的个数；empty 属性表示栈内是否含有元素。 栈的实现实现一个栈，当务之急是决定存储数据的底层数据结构。这里采用的是数组。定义一个Stack类的构造函数 1234567function Stack() &#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek;&#125; push()方法：当向栈中压入一个新元素时，需要将其保存在数组中变量top所对应的位置，然后将top值加1，让其指向数组中下一个空位置123function push(element) &#123; this.dataStore[this.top++] = element;&#125; pop()方法：出栈，与push()方法相反，返回栈顶元素，同时将变量top的值减1123function pop() &#123; return this.dataStore[--this.top];&#125; peek()方法：返回栈顶元素（即第top-1个位置的元素）123function peek() &#123; return this.dataStore[this.top-1];&#125; length(): 栈内存储了多少个元素123function length() &#123; return this.top;&#125; clear()方法：清空栈元素123function clear() &#123; this.top = 0;&#125; 使用Stack类数制间的相互转换可以利用栈将一个数字从一种数制转换为另一种数制。]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表]]></title>
    <url>%2FBlog%2Fposts%2F14.html</url>
    <content type="text"><![CDATA[列表的抽象数据类型列表是一组有序的数据，每个列表中的数据项称为元素，在JavaScript中，列表中的元素可以是任意数据类型，列表中可以保存多少元素没有事先限定，实际使用时元素的数量受到程序内存的限制。 列表的抽象数据类型定义如下所示： 属性名 说明 listSize(属性) 列表的元素个数 pos(属性) 列表的当前位置 length(属性) 返回列表中元素的个数 clear(方法) 清空列表中的所有元素 toString(方法) 返回列表的字符串形式 getElement(方法) 返回当前位置的元素 insert(方法) 在现有元素后插入新元素 append(方法) 在列表的末尾添加新元素 remove(方法) 从列表中删除元素 front(方法) 将列表的当前位置移动到第一个元素 end(方法) 将列表的当前位置移动到最后一个元素 prev(方法) 将当前位置前移一位 next(方法) 将当前位置后移一位 currPos(方法) 返回列表的当前位置 moveTo(方法) 将当前位置移动到指定位置 实现列表类定义一个List类： 123456789101112131415161718192021function List() &#123; this.listSize = 0; this.pos = 0; this.dataStore = []; # 初始化一个空数组来保存列表元素 this.clear = clear; this.find = find; this.toString = toString; this.insert = insert; this.append = append; this.remove = remove; this.front = front; this.end = end; this.prev = prev; this.next = next; this.length = length; this.currPos = currPos; this.moveTo = moveTo; this.getElement = getElement; this.length = length; this.contains = contains;&#125; append：给列表添加元素123function append(element) &#123; this.dataStore(this.listSize++) = element;&#125; find: 在列表中查找某一元素find()方法通过对数组对象dataStore进行迭代，查找给定的元素。如果找到就返回该元素在列表中的位置，否则返回-1。 123456789function find(element) &#123; for (let i = 0; i &lt; this.dataStore.length; i++) &#123; if (this.dataStore[i] == element) &#123; return i; &#125; &#125; return -1;&#125; remove： 从列表中删除元素12345678function remove(element) &#123; if(this.find(element) &gt; -1) &#123; this.dataStore.splice(this.find(element), 1); --this.listSize; return true; &#125; return false;&#125; length: 列表中有多少个元素123function length() &#123; return this.listSize;&#125; toString: 显示列表中的元素123function toString() &#123; return this.dataStore;&#125; 该方法返回的是一个数组，不是字符串。 insert: 向列表中插入一个元素(假设插入是指插入到某个元素之后)123456789function insert(elment,after) &#123; var insertPos = this.find(after); if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos+1, 0, element) ++listSize; return true; &#125; return false;&#125; clear: 清空列表中的所有元素12345function clear() &#123; delete this.dataStore; this.dataStore = []; this.listSize = this.pos = 0;&#125; contains: 判断给定值是否在列表中12345678function contains(element) &#123; for (let i = 0; i &lt; this.dataStore.length; i++) &#123; if (this.dataStore[i] == element) &#123; return true; &#125; &#125; return false;&#125; 遍历列表 front: 将列表的当前位置移动到第一个元素 123function front() &#123; this.pos = 0;&#125; end: 将列表的当前位置移动到最后一个元素 123function end() &#123; this.pos = this.listSize - 1;&#125; prev: 将当前位置前移一位 12345function prev() &#123; if (this.pos &gt; 0) &#123; --this.pos; &#125;&#125; next: 将当前位置后移一位 12345function next() &#123; if(this.pos &lt; (this.listSize-1)) &#123; ++this.pos; &#125;&#125; currPos: 返回列表的当前位置 123function currPos() &#123; return this.pos;&#125; moveTo: 将当前位置移动到指定位置 123function moveTo(position) &#123; this.pos = position;&#125; getElement: 返回列表的当前位置的元素 123function getElement() &#123; return this.dataStore[this.pos];&#125; 使用迭代器访问列表使用迭代器，可以不用关心数据的内部存储方式，以实现对列表的遍历。使用迭代器的优点如下： 访问列表元素时不必关心底层的数据存储结构 当为列表添加一个元素时，索引的值就不对了，此时只用更新列表，不用更新迭代器。 可以用不同类型的数据存储方式实现 cList 类，迭代器为访问列表里的元素提供了一种统一的方式。 使用迭代器遍历列表的例子： 123for (names.front(); names.currPos() &lt; names.length; names.next()) &#123; console.log(names.getElement());&#125; 在for 循环的一开始，将列表的当前位置设置为第一个元素。只要currPos 的值小于列表的长度，就一直循环，每一次循环都调用next() 方法将当前位置向前移动一位。]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组、对象数组]]></title>
    <url>%2FBlog%2Fposts%2F23.html</url>
    <content type="text"><![CDATA[JavaScripta中对数组的定义JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为JavaScript 对象中的属性名必须是字符串。数组在JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。JavaScript 中的数组，严格来说应该称作对象，是特殊的JavaScript 对象，在内部被归类为数组。由于Array 在JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。 数组的基本使用方法以及迭代器方法等在这里就不介绍了，参照博客的JavaScript高级程序设计中的引用类型，这里介绍一些关于二维数组以及对象数组等知识。 二维数组处理二维数组的元素处理二维数组中的元素，有两种最基本的方式：按列访问和按行访问。对于这两种方式，均采用一组嵌入式的for循环，对于按列访问，外层循环对应行，内层循环对应列。示例如下：数组grades的每一行对应一个学生的成绩记录，我们可以将该学生的所有成绩相加，然后除以科目数得到该学生的平均成绩。 123456789101112var grades = [[89,77,78], [76,82,81], [91,94,89]];var total = 0;var average = 0.0;for (let row = 0; row &lt; grades.length; row++) &#123; for (let col = 0; col &lt; grades[row].length; col++) &#123; total += grades[row][col]; &#125; average = total/grades[row].length; console.log("studuent" + parseInt(row+1)+ "average:" + average.toFixed(2)); total = 0; average = 0.0&#125; 结果如下所示： 123studuent 1 average: 81.33studuent 2 average: 79.67studuent 3 average: 91.33 对于按列访问，只需稍微调整for循环的顺序，使外层循环对应列，内层循环对应行即可。JavaScript在处理参差不齐的数组时表现良好，很多语言在处理这种参差不齐的数组时表现都不是很好 对象数组数组不仅可以包含基本数据类型的元素，还可以包含对象，数组的方法对对象依然适用。示例如下： 123456789101112131415161718192021222324function Point(x,y) &#123; this.x = x; this.y = y;&#125;function displayPts(arr) &#123; for (var i = 0; i &lt; arr.length; ++i) &#123; console.log(arr[i].x + ", " + arr[i].y); &#125;&#125;var p1 = new Point(1,2);var p2 = new Point(3,5);var p3 = new Point(2,8);var p4 = new Point(4,4);var points = [p1,p2,p3,p4];for (var i = 0; i &lt; points.length; ++i) &#123; console.log("Point " + parseInt(i+1) + ": " + points[i].x + ", " + points[i].y);&#125;var p5 = new Point(12,-3);points.push(p5);console.log("After push: ");displayPts(points);points.shift();console.log("After shift: ");displayPts(points); 结果如下所示： 123456789101112131415Point 1: 1, 2Point 2: 3, 5Point 3: 2, 8Point 4: 4, 4After push:1, 23, 52, 84, 412, -3After shift:3, 52, 84, 412, -3 对象中的数组在对象中，可以使用数组存储复杂的数据，比如：我们创建了一个对象，用于保存观测到的周最高气温，该对象有两个方法，一个方法用来增加一条新的气温记录，另外一个方法用来计算存储在对象中的平均气温。代码如下： 12345678910111213141516171819202122232425function weekTemps() &#123; this.dataStore = []; this.add = add; this.average = average;&#125;function add(temp) &#123; this.dataStore.push(temp);&#125;function average() &#123; var total = 0; for (var i = 0; i &lt; this.dataStore.length; ++i) &#123; total += this.dataStore[i];&#125;return total / this.dataStore.length;&#125;var thisWeek = new weekTemps();thisWeek.add(52);thisWeek.add(55);thisWeek.add(61);thisWeek.add(65);thisWeek.add(55);thisWeek.add(50);thisWeek.add(52);thisWeek.add(49);console.log(thisWeek.average()); # 54.875]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展的对象功能]]></title>
    <url>%2FBlog%2Fposts%2F22.html</url>
    <content type="text"><![CDATA[对象类别对象类别包括： 普通对象：拥有JS对象所有默认的内部行为。 奇异对象：其内部行为在某些方面有别于默认行为。 标准对象：Array、Data等标准对象。 内置对象：在脚本开始运行时由JS运行环境提供的对象，所有的标准对象都是内置对象。 属性初始化器的速记法ES5方法： 12345678910111213function createPerson(name, age) &#123; return &#123; name: name, age: age &#125;;&#125;;var person = &#123; name: "Nicholas", sayName: function() &#123; console.log(this.name); &#125;&#125;; ES6重写方法： 12345678910111213function createPerson(name, age) &#123; return &#123; name, age &#125;;&#125;;var person = &#123; name: "Nicholas", sayName() &#123; console.log(this.name); &#125;&#125; Object.is()方法当在 JS 中要比较两个值时，你可能会使用相等运算符（ == ）或严格相等运算符（ ===）。为了避免在比较时发生强制类型转换，许多开发者更倾向于使用后者。但严格相等运算符也并不完全准确，例如，它认为 +0 与 -0 相等，即使这两者在 JS 引擎中有不同的表示；另外 NaN === NaN 会返回 false ，因此有必要使用 isNaN() 函数来正确检测 NaN 。 1234567891011121314console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == 5); // trueconsole.log(5 == "5"); // trueconsole.log(5 === 5); // trueconsole.log(5 === "5"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, "5")); // false Object.assign()方法Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，示例如下： 12345678910111213var receiver = &#123;&#125;;Object.assign(receiver, &#123; type: "js", name: "file.js" &#125;, &#123; type: "css" &#125;);console.log(receiver.type); // "css"console.log(receiver.name); // "file.js"receiver. 自有属性的枚举属性自有属性枚举时基本顺序如下： 所有的数字类型键，按升序排列。 所有的字符串类型键，按被添加到对象的顺序排列。 所有的符号类型（详见第六章）键，也按添加顺序排列。 示例如下： 12345678910var obj = &#123; a: 1, 0: 1, c: 1, 2: 1, b: 1, 1: 1&#125;;obj.d = 1;console.log(Object.getOwnPropertyNames(obj).join("")); // "012acbd"]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2FBlog%2Fposts%2F21.html</url>
    <content type="text"><![CDATA[带参数默认值的函数ES6中的参数默认值JS函数可以接受任意数量的参数，而无视函数声明处的参数数量。这样就会让你定义的函数可以使用不同的参数数量来调用，调用时未提供的参数经常会使用默认值来代替。ES5为参数提供默认值比较麻烦，需要采用或语法（当变量为0时还有可能会导致错误）ES6能很容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。例如： 123function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 函数的剩余部分&#125; 上面的函数只要求第一个参数始终要被传递。其余两个参数则都有默认值，这使得函数体更为小巧，因为不需要再添加更多代码来检查缺失的参数值如果使用全部三个参数来调用 makeRequest() ，那么默认值将不会被使用，例如： 12345678// 使用默认的 timeout 与 callbackmakeRequest("/foo");// 使用默认的 callbackmakeRequest("/foo", 500);// 不使用默认值makeRequest("/foo", 500, function(body) &#123; doSomething(body);&#125;); 在本例中，只有在未传递第二个参数、或明确将第二个参数值指定为 undefined 时，timeout 的默认值才会被使用。 参数默认值如何影响arguments对象arguments对象会在使用参数默认值时有不同的表现。在ES5的非严格模式下，arguments对象会反映出具名参数的变化，如下面的代码所示： 123456789function mixArgs(first, second) &#123; console.log(first === arguments[0]); console.log(second === arguments[1]); first = "c"; second = "d"; console.log(first === arguments[0]); console.log(second === arguments[1]);&#125;mixArgs("a", "b"); 输出结果如下： 1234truetruetruetrue 但是在ES5的严格模式下，关于 arguments 对象的这种混乱情况被消除了，它不再反映出具名参数的变化。在严格模式下重新使用上例中的函数，结果如下： 1234truetruefalsefalse 在使用ES6参数默认值的函数中，arguments对象的表现总是会与ES5的严格模式一致，无论此时函数是否明确运行在严格模式下。参数默认值的存在触发了arguments对象与具名参数的分离。示例如下所示： 1234567891011// 非严格模式function mixArgs(first, second = "b") &#123;console.log(arguments.length);console.log(first === arguments[0]);console.log(second === arguments[1]);first = "c";second = "d"console.log(first === arguments[0]);console.log(second === arguments[1]);&#125;mixArgs("a"); 输出： 123451truefalsefalsefalse 参数默认值表达式参数默认值最有意思的特性就是默认值并不要求一定时基本类型的值。例如： 12345678910let value = 5;function getValue() &#123; return value++;&#125;function add(first, second = getValue()) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 6console.log(add(1)); // 7 此处若未提供第二个参数， getValue() 函数就会被调用以获取正确的默认值。需要注意的是，仅在调用 add() 函数而未提供第二个参数时， getValue() 函数才会被调用，而在getValue() 的函数声明初次被解析时并不会进行调用。这意味着 getValue() 函数若被写为可变的，则它有可能会返回可变的值 也可以将前面的参数作为后面参数的默认值。例如： 12345function add(first, second = first) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(1)); // 2 参数默认值的暂时性死区看下面的例子： 12345function add(first = second, second) &#123; return first + second;&#125;console.log(add(1, 1)); // 2console.log(add(undefined, 1)); // 抛出错误 本例中调用add(1, 1)与add(undefined, 1)，对应着以下的后台代码： 123456// JS 调用 add(1, 1) 可表示为let first = 1;let second = 1;// JS 调用 add(1) 可表示为let first = second;let second = 1; 本例中调用 add(undefined, 1) 抛出了错误，是因为在 first 被初始化时 second 尚未被初始化。此处的 second 存在于暂时性死区内，对于 second 的引用就抛出了错误。 使用不具名参数ES5中的不具名参数12345678910111213141516171819function pick(object) &#123; let result = Object.create(null); console.log(object); // &#123; title: 'Understanding ES6', author: 'Nicholas C. Zakas', year: 2015 &#125; console.log(arguments); // [Arguments] &#123;'0':&#123; title: 'Understanding ES6',author: 'Nicholas C. Zakas',year: 2015 &#125;,'1': 'title','2': 'author','3': 'year' &#125; //从第二个参数开始处理 for (let i = 1, len = arguments.length; i &lt; len; i++) &#123; result[arguments[i]] = object[arguments[i]]; &#125; return result; &#125; let book = &#123; title: "Understanding ES6", author: "Nicholas C. Zakas", year: 2015 &#125;;let bookData = pick(book, "title", "author", "year");console.log(bookData.title); //"Understanding ES6"console.log(bookData.author); // "Nicholas C. Zakas"console.log(bookData.year); // 2015 这个 pick() 函数有两点需要注意。首先，完全看不出该函数能够处理多个参数，你能为其再多定义几个参数，但依然不足以标明该函数能处理任意数量的参数。其次，由于第一个参数被命名并被直接使用，当你寻找需要复制的属性时，就必须从 arguments 对象索引位置 1开始处理而不是从位置 0 。要记住使用 arguments 的适当索引值并不一定困难，但毕竟多了一件需要留意的事。ES6 引入了剩余参数以便解决这个问题。 剩余参数剩余参数由三个点（…）与一个紧跟着的具名参数指定，它会是包含传递给函数的剩余参数的一个数组。pick()函数可以像下面这样用剩余参数来重写： 1234567function pick(object, ...keys) &#123; let result = Object.create(null); for (let i = 0, len = keys.length; i &lt; len; i++) &#123; result[keys[i]] = object[keys[i]]; &#125; return result;&#125; 在上面的函数中，keys是一个包含所有在object之后的参数的剩余参数（这与包含所有参数的arguments不同，后者会连第一个参数都包含在内）。即我们可以对keys从头到尾进行迭代，而不需要有所顾虑。 剩余参数的限制条件：一是函数只能有一个剩余参数，并且它必须被放在最后；二是剩余参数不能在对象字面量的setter属性中使用。 剩余参数如何影响arguments对象：arguments 对象在函数被调用时反映了传入的参数，与剩余参数能协同工作，就像如下程序所演示的： 1234567function checkArgs(...args) &#123; console.log(args.length); console.log(arguments.length); console.log(args[0], arguments[0]); console.log(args[1], arguments[1]);&#125;checkArgs("a", "b"); 调用 checkArgs() 输出了： 123422a ab b arguments 对象总能正确反映被传入函数的参数，而无视剩余参数的使用。 函数构造器的增强能力Function 构造器允许你动态创建一个新函数，但在 JS 中并不常用。传给该构造器的参数都是字符串，它们就是目标函数的参数与函数体，这里有个范例： 12var add = new Function("first", "second", "return first + second");console.log(add(1, 1)); //2 扩展运算符与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。 比如下面的Math.max() 方法，它能接收任意数量的参数，并会返回其中的最大值。 123let value1 = 25, value2 = 50;console.log(Math.max(value1, value2)); //50 但是Math.max() 方法并不允许你传入一个数组，因此无法判断一个数组中的值。ES6 的扩展运算符令这种情况变得简单。可以像使用剩余参数那样在该数组前添加 … ，并直接将其传递给 Math.max() 。 JS 引擎将会将该数组分割为独立参数并把它们传递进去，就像这样： 123let values = [25, 50, 75, 100]//等价于 console.log(Math.max(25, 50, 75, 100));console.log(Math.max(...values)); // 100 也可以将与其他参数混用，示例如下： 12let values = [-25, -50, -75, -100]console.log(Math.max(...values, 0)); // 0 ES6的名称属性ES6 给所有函数添加了name属性。如下所示： 123456789101112131415var doSomething = function doSomethingElse() &#123; // ...&#125;;var person = &#123; get firstName() &#123; return "Nicholas" &#125;, sayName: function() &#123; console.log(this.name); &#125;&#125;console.log(doSomething.name); // "doSomethingElse"console.log(person.sayName.name); // "sayName"var descriptor = Object.getOwnPropertyDescriptor(person, "firstName");console.log(descriptor.get.name); // "get firstName" 本例中的 doSomething.name 的值是 “doSomethingElse” ，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。 person.sayName() 的 name 属性值是”sayName” ，正如对象字面量指定的那样。类似的， person.firstName 实际是个 getter 函数，因此它的名称是 “get firstName” ，以标明它的特征；同样， setter 函数也会带有”set” 的前缀（ getter 与 setter 函数都必须用 Object.getOwnPropertyDescriptor() 来检索）。 函数名称还有另外两个特殊情况。使用 bind() 创建的函数会在名称属性值之前带有”bound” 前缀；而使用 Function 构造器创建的函数，其名称属性则会有 “anonymous” 前缀，正如此例： 12345var doSomething = function() &#123; // ...&#125;;console.log(doSomething.bind().name); // "bound doSomething"console.log((new Function()).name); // "anonymous" 明确函数的双重用途在ES5以及更早的版本中，函数根据是否使用new来调用而有双重用途，当使用new时，函数内部的this是一个新对象，并作为函数的返回值。如下例所示： 1234567function Person(name) &#123; this.name = name;&#125;var person = new Person("Nicholas");var notAPerson = Person("Nicholas");console.log(person); // "[Object object]"console.log(notAPerson); // "undefined" JS 为函数提供了两个不同的内部方法： [[Call]] 与 [[Construct]] 。当函数未使用 new进行调用时， [[call]] 方法会被执行，运行的是代码中显示的函数体。而当函数使用 new进行调用时， [[Construct]] 方法则会被执行，负责创建一个被称为新目标的新的对象，并且使用该新目标作为 this 去执行函数体。拥有 [[Construct]] 方法的函数被称为构造器。 在ES5中判断函数如何被使用在 ES5 中判断函数是不是使用了 new 来调用（即作为构造器），最流行的方式是使用instanceof。 12345678910function Person(name) &#123; if (this instanceof Person) &#123; this.name = name; // 使用 new &#125; else &#123; throw new Error("You must use new with Person.") &#125;&#125;var person = new Person("Nicholas");var notAPerson = Person("Nicholas"); // 抛出错误var notAPerson = Person.call(person, "Michael"); // 奏效了！ 此处对 this 值进行了检查，来判断其是否为构造器的一个实例：若是，正常继续执行；否则抛出错误。这能奏效是因为 [[Construct]] 方法创建了 Person 的一个新实例并将其赋值给 this 。可惜的是，该方法并不绝对可靠，因为在不使用 new 的情况下 this 仍然可能是 Person 的实例.调用 Person.call() 并将 person 变量作为第一个参数传入，这意味着将 Person 内部的this 设置为了 person 。对于该函数来说，没有任何方法能将这种方式与使用 new 调用区分开来。 new.target元属性元属性指的是“非对象”（例如 new上的一个属性），并提供关联到它的目标的附加信息。当函数的 [[Construct]] 方法被调用时， new.target 会被填入 new 运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的 this 值。而若 [[Call]] 被执行， new.target 的值则会是undefined。 123456789function Person(name) &#123; if (typeof new.target !== "undefined") &#123; this.name = name; // 使用 new &#125; else &#123; throw new Error("You must use new with Person.") &#125;&#125;var person = new Person("Nicholas");var notAPerson = Person.call(person, "Michael"); // 出错！ 使用 new.target 而非 this instanceof Person ， Person 构造器会在未使用 new 调用时正确地抛出错误。也可以检查 new.target 是否被使用特定构造器进行了调用，例如以下代码： 123456789101112function Person(name) &#123; if (new.target === Person) &#123; this.name = name; // 使用 new &#125; else &#123; throw new Error("You must use new with Person.") &#125;&#125;function AnotherPerson(name) &#123;Person.call(this, name);&#125;var person = new Person("Nicholas");var anotherPerson = new AnotherPerson("Nicholas"); // 出错！ 块级函数ES6中可以使用块级函数。块级函数与let函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除。关键区别在于：块级函数会被提升到所在代码块的顶部；而使用let的函数表达式则不会。正如以下范例所示： 1234567891011121314"use strict";if (true) &#123; console.log(typeof doSomething); // "function" function doSomething() &#123; // ... &#125; console.log(typeof doAnotherSomething); //抛出错误 let doAnotherSomething = function () &#123; // ... &#125; doSomething(); doAnotherSomething();&#125;console.log(typeof doSomething); // "undefined" 此处代码在 typeof doAnotherSomething 被执行时中断了，因为 let 声明尚未被执行，将doSomething() 放入了暂时性死区。 箭头函数箭头函数与传统的JS函数有以下不同： 没有this、super、arguments，也没有 new.target 绑定： this 、 super 、arguments 、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。 不能被使用 new 调用： 箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。 没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。 不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。 没有 arguments 对象： 既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。 不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。 箭头函数语法接收单个参数并返回它本身的语法： 12345var reflect = value =&gt; value;//有效等价于：var reflect = function(value) &#123; return value;&#125;; 传入多个参数，只运行一条语句的语法： 12345var sum = (num1, num2) =&gt; num1 + num2;//有效等价于：var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 传入多个参数且函数体包含多条语句的语法如下： 1234567var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;;// 有效等价于：var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 创建空函数： 123var doNothing = () =&gt; &#123;&#125;;// 有效等价于：var doNothing = function() &#123;&#125;; 返回对象字面量语法如下： 12345678var getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;);// 有效等价于：var getTempItem = function(id) &#123; return &#123; id: id, name: "Temp" &#125;;&#125;; 创建立即调用函数表达式JS中使用函数的一种流行方式是创建立即调用函数表达式（IIFE），IIFE允许你定义一个匿名函数并在未保存引用的情况下立刻调用它。箭头函数同样能实现创建立即函数表达式的功能。如下所示： 1234567891011121314151617181920// 箭头函数表达式let person = ((name) =&gt; &#123; return &#123; getName: function() &#123; return name; &#125;&#125;;&#125;)("Nicholas");console.log(person.getName()); // "Nicholas"// 有效的JS函数表达式let person = function(name) &#123; return &#123; getName: function() &#123; return name; &#125;&#125;;&#125;("Nicholas");console.log(person.getName()); // "Nicholas" 没有this绑定JS最常见的错误领域之一就是在函数内的this绑定。由于一个函数内部的this值可以被改变，这取决于调用函数时的上下文，因此完全可能错误地影响了一个对象，尽管本意是要修改另一个对象。用箭头函数不会出现这个问题，箭头函数没有this绑定，即箭头函数内部的this值只能通过查找作用域链来确定，如果箭头函数被包含在一个非箭头函数内，那么this值就会与函数的相等；否则，this值就是全局对象。示例如下： 12345678910var PageHandler = &#123; id: "123456", init: function() &#123; document.addEventListener("click", event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log("Handling " + type + " for " + this.id); &#125;&#125;; 上例中的事件处理函数是一个调用this.doSomething()的箭头函数，它的this值与init()方法的相同。 箭头函数与数组能使用回调函数的数组方法（例如sort()、map()与reduce()方法），都能从箭头函数的简洁语法中获得收益，它将看似复杂的需求转换为简单的代码。例如： 1var result = values.sort((a,b) =&gt; a - b); 没有arguments绑定尽管箭头函数没有自己的arguments对象，但仍然能访问包含它的函数的arguments对象。无论此后箭头函数在何处执行，该对象都是可用的。例如： 12345function createArrowFunctionReturningFirstArg() &#123; return () =&gt; arguments[0];&#125;var arrowFunction = createArrowFunctionReturningFirstArg(5);console.log(arrowFunction()); // 5 识别箭头函数尽管语法不同，箭头函数依然属于函数，并能被照常识别。例如下面的代码： 123var comparator = (a, b) =&gt; a - b;console.log(typeof comparator); // "function"console.log(comparator instanceof Function); // true console.log()的输出揭示了typeof与instanceof在作用于箭头函数时的行为，与作用在其他函数上一样。同理，也可以对箭头函数使用call()、apply()、与bind()方法，但是函数的this绑定不受影响。例如： 12345var sum = (num1, num2) =&gt; num1 + num2;console.log(sum.call(null, 1, 2)); // 3console.log(sum.apply(null, [1, 2])); // 3var boundSum = sum.bind(null, 1, 2);console.log(boundSum()); // 3 上例中的函数的作用域为null,没设定，是sum的作用域。 尾调用优化尾调用指的是调用函数的语句是另一个函数的最后语句。在ES5引擎中实现的尾调用，其处理就像其他函数一样：一个新的栈帧被创建并推到调用栈之上，用于表示该次函数调用，但是这也意味着之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。 123function doSomething() &#123;return doSomethingElse(); // 尾调用&#125; ES6在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。当满足以下条件时，尾调用优化会清除栈帧并再次利用它，而不是为尾调用创建新的栈帧： 尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）。 进行尾调用的函数在尾调用返回结果后不能做额外操作。 尾调用的结果作为当前函数的返回值。]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串与正则表达式]]></title>
    <url>%2FBlog%2Fposts%2F20.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[块级作用域绑定]]></title>
    <url>%2FBlog%2Fposts%2F19.html</url>
    <content type="text"><![CDATA[变量声明的工作方式历来是JS编程中最微妙的部分之一。在大多数类C语言中，变量（或绑定）总是在它被声明的地方创建。然而JS就不是这样，变量实际创建的位置取决于你如何声明它，而ES6提供了额外选择以便你能更轻易地控制变量的作用域。 var声明与变量提升使用var关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部），这种方式就是变量提升。如下例所示： 1234567891011function getValue(condition) &#123; if (condition) &#123; var value = "blue"; // 其他代码 return value; &#125; else &#123; // value 在此处可访问，值为 undefined return null; &#125; // value 在此处可访问，值为 undefined&#125; 如果不太熟悉 JS ，或许会认为仅当 condition 的值为 true 时，变量 value 才会被创建。但实际上，value 无论如何都会被创建。 JS 引擎在后台对 getValue 函数进行了调整，就像这样： 12345678910function getValue(condition) &#123; var value; if (condition) &#123; value = "blue"; // 其他代码 return value; &#125; else &#123; return null; &#125;&#125; value 变量的声明被提升到了顶部，而初始化工作则保留在原处。这意味着在 else 分支内value 变量也是可访问的，此处它的值会是 undefined ，因为它并没有被初始化。 块级声明块级声明即让所声明的变量在指定块的作用域外无法被访问。块级作用域（又被称为词法作用域）在如下情况被创建： 在一个函数内部 在一个代码块（由一对花括号包裹）内部 let声明let声明与var的语法一致，但是let声明不会被提升到当前代码块的顶部，需要手动将let声明放置到顶部，以便让变量在整个代码块内部使用。let声明会将变量的作用域限制在当前代码块中。范例如下： 1234567891011function getValue(condition) &#123; if (condition) &#123; let value = "blue"; // 其他代码 return value; &#125; else &#123; // value 在此处不可用 return null; &#125; // value 在此处不可用&#125; 禁止重复声明如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行let声明就会导致抛出错误。但是在嵌套的作用域内使用let声明一个同名的新变量，则不会抛出错误。范例如下： 1234567var count = 30;// 抛出错误let count = 40;// 不会抛出错误if (condition) &#123; let count = 40;&#125; 常量声明使用const语法进行声明的变量是常量，在设置完成后就不能再被改变，正因为如此，所有的const变量都需要在声明时进行初始化。示例如下： 1234// 有效的常量const maxItems = 30;// 语法错误；未进行初始化const name; 对比常量声明与let声明： 常量声明与let声明一样，都是块级声明。即常量在声明它们的语句块外部是无法访问的，并且声明也不会被提升；同样不能重复声明。 使用const声明对象：const声明会阻止对于变量绑定与变量自身值的修改，意味着const声明并不会阻止对变量成员的修改。如下例所示： 123456789const person = &#123; name: "Nicholas"&#125;;// 工作正常person.name = "Greg";// 抛出错误person = &#123;name: "Greg"&#125;; 上例中，修改 person.name 是可能的，并不会抛出错误，因为该操作只修改了 person 对象的成员，而没有修改 person 的绑定值。当代码试图为 person 对象自身赋值时（这会改变变量绑定），就会导致错误。 暂时性死区使用let或const声明的变量在达到声明处之前是无法访问的，试图访问会导致一个引用错误。 循环中的块级绑定循环内的函数长期以来，var的特点是使得循环变量在循环作用域之外仍然可被访问，于是在循环内创建函数就变得很有问题。例如下例： 123456789var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 输出数值 "10" 十次&#125;); 上例预期为这段代码会输出0到9的数值，但它却在同一行将数值10输出了十次。因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一变量的引用。 循环内的let声明let是属于局部作用域声明，因此使用let代替var将避免上面的问题。 123456789var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); // 从 0 到 9 依次输出&#125;) 在循环中let声明每次都创建了一个新的i变量，因此在循环内部创建的函数获得了各自的i副本，而每个i副本的值都在每次循环迭代声明变量的时候被确定了。 循环内的常量声明ES6中没有明确禁止在循环中使用const声明，但是它会根据循环方式的不同而有不同行为。在常规的for循环中，可以在初始化时使用const，但循环会在你试图改变该变量的值时抛出错误。例如： 1234567var funcs = [];// 在一次迭代后抛出错误for (const i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125; const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。const 能够在 for-in 与 for-of 循环内工作，是因为循环为每次迭代创建了一个新的变量绑定，而不是试图去修改已绑定的变量的值 全局块级绑定在全局作用域上使用var时，会创建一个新的全局变量，并成为全局对象（在浏览器中是window）的一个属性，即使用var可能会无意覆盖一个已有的全局属性。在全局作用域上使用let或const时，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。即不能使用let或const来覆盖一个全局变量，只能将其屏蔽。]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数表达式]]></title>
    <url>%2FBlog%2Fposts%2F18.html</url>
    <content type="text"><![CDATA[递归递归函数是在一个函数通过名字调用自身的情况下构成的，下面先看一个错误使用递归函数的例子： 1234567891011function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num-1); &#125;&#125;var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(1)); // 1console.log(anotherFactorial(4)); //TypeError: factorial is not a function 原因是：以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial变量设置为null,结果指向原始函数的引用只剩下一个，但在接下来调用anotherFactorial()时，由于必须执行factorial()，而factorial已经不再是函数，所以就会导致错误，该问题可以用arguments.callee解决。arguments.callee是一个指向正在执行的函数的指针。但在严格模式下不能通过脚本访问arguments.callee，因此在严格模式下可以使用命名函数表达式来达成相同的效果 1234567891011121314151617181920212223# 非严格模式下function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num-1); &#125;&#125;var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4)); //24#严格模式下var factorial = (function f(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num-1); &#125;&#125;);var anotherFactorial = factorial;factorial = null;console.log(anotherFactorial(4)); //24 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另一个函数。 闭包与变量作用链的配置机制引出一个值得注意的副作用：即闭包只能取得包含函数中任何变量的最后一个值。但是闭包保存的是整个变量对象，而不是某个特殊的变量。示例如下： 123456789101112131415function createFunctions() &#123; var result = new Array(); for (var i=0;i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125;; &#125;(i); &#125; return result;&#125;result = createFunctions();for (let item of result) &#123; console.log(item()) //0 1 2 3 4 5 6 7 8 9&#125; 上面的函数没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值，在调用每个匿名函数时，传入了变量i,由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num，在匿名函数内部，又创建并返回了一个访问num的闭包，注意这样的结果是result返回的是一个指向结果的指针组成的数组，调用数组中的每个指针才能得到结果。 关于this在闭包中使用this对象有可能会导致一些问题，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。但是，匿名函数的执行环境具有全局性，因此其this对象通常指向window，有时候由于编写闭包的方式不同，这一点不会那么明显。先看下面的例子： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); //undefined(在严格模式下) "The Window"(在非严格模式下) 上面的代码在严格模式下取得的是undefined，在做项目时经常出现的问题，非严格模式下取得的是全局name的变量，没有取得其包含作用域（或外部作用域）的this对象每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量，但是，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下所示： 123456789101112var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); //'My Object' 上面的代码中最重要的不同时在定义匿名函数之前，把this对象赋值给了一个名为that的变量，在定义闭包之后，闭包也可以访问这个变量，即使在函数返回之后，this也仍然引用着object，所以上面的调用有返回值。this与arguments一样存在同样的问题，如果想访问arguments对象，必须将对该对象的引用保存在另一个闭包能够访问到的变量中。 私有变量严格来说，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过倒是又一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包含函数的参数、局部变量和在函数内部定义的其他函数。示例如下： 1234function add(num1,num2) &#123; var sum = num1 + num2; return sum;&#125; 在上面这个函数内部，有3个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，利用这一点就可以创建用于访问私有变量的公有方法。有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式，第一种是在构造函数中定义特权方法，基本模式如下： 1234567891011121314function MyObject() &#123; //私有变量和私有函数 var privateVariable = 10; function privateFunction() &#123; return false; &#125; //特权方法 this.publicMethod = function() &#123; privateVariable++; return privateFunction(); &#125;;&#125;var myObject = new MyObject();console.log(myObject.publicMethod()) //11 这个模式在构造函数内部定义了所有私有变量和函数，然后又创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。上面的例子中的变量privateVariable和函数privateFunction()只能通过特权方法publicMethod()来访问。]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒模型]]></title>
    <url>%2FBlog%2Fposts%2F16.html</url>
    <content type="text"><![CDATA[理解盒模型元素盒子的属性分为以下三类： 边框： 可以设置边框的宽窄、样式和颜色； 内边距：可以设置盒子内容区与边框的间距； 外边距：可以设置盒子与相邻元素的间距。 如下面的这个盒模型示意图所示，展示了HTML 元素的边框、内边距和外边距之间的关系 外边距是边框向外推其他元素，而内边距是从边框向内推元素的内容，一个盒子有4条边，因此与边框、内边距和外边距相关的属性也各有4个，分别是上（top）、右（right）、下（bottom）、左（left）。CSS提供了简写样式CSS为边框、内边距和外边距分别规定了简写属性，可以通过一条声明就可以完成设定，在每个简写声明中，属性值的顺序都是上、右、下、左（顺时针旋转顺序） 1234567891011不使用简写属性&#123; margin-top:5px; margin-right:10px; margin-bottom:12px; margin-left:8px;&#125;使用简写属性&#123; margin:5px 10px 12px 8px;&#125; 注意：4个值之间有空格，但不能是其他分隔符（比如逗号之类的），甚至不用把4值都写出来，如果哪个值没有写，就使用对边的值。 123456&#123; margin:12px 10px 6px; #最后一个值没有写就会使用对边的值即10px&#125;&#123; margin:12px; #4个边都取这个值&#125; 每个盒子的属性也分三种粒度，到底选择哪个粒度的属性，要看你想选择哪条边，以及那条边的哪个属性，这三种粒度从一般到特殊分别是举例如下： 1234567891011121. 全部三个属性，全部4条边&#123; border:2px dashed red;&#125;2. 1个属性，全部4条边&#123; border-style:dashed;&#125;3. 1个属性，1条边&#123; border-left-style:dashed;&#125; 混合使用这三种粒度的简写属性达成设计目标是很常见的，。比如说吧，我想为盒子的上边和下边添加4 像素宽的红色边框，为左边添加1 像素宽的红色边框，而右边没有边框。可以这样写： 123&#123;border:4px solid red;&#125; /* 先给4 条边设置相同的样式 */&#123;border-left-width:1px;&#125; /* 修改左边框宽度 */&#123;border-right:none;&#125; /* 移除右边框 */ 盒子边框边框有3个相关属性 宽度(border-width)：可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值； 样式(border-style): 有none、hidden、dotted、dashed、solid、double、groove、ridge、inset 和outset 等文本值。 颜色(border-color): 可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。 12p.warning &#123;border:solid #f33;&#125; #所有带有warning类的段落都会带有一个4像素宽的红色实心边框p.warning &#123;border-width:4px 1px 1px 4px;&#125; #修改边框宽度 盒子内边距(padding)内边距是盒子内容区与盒子边框之间的距离。同样遵从简写样式，依据上、右、下、左的顺序。 盒子外边距(margin)推荐使用下面的这条规则作为样式表的第一条规则： 1* &#123;margin:0; padding:0;&#125; 根据不同需要修改外边距与内边距。 叠加外边距垂直方向上的边距会叠加，但是像下例这样上下边距相遇时，他们就会相互叠加，直到一个外边距碰到另一个元素的边框。 123/*为简明起见，省略了字体声明*/p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px;margin-bottom:30px;&#125; 上例中的第一段的下外边距与第二段的上外边距之间的外边距是50像素，不是（50+30），因为外边距叠加。较宽的外边距决定两个元素最终离多远 外边距的单位根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间距，不受字号变大或变小的影响。而对于上、下外边距，以em 为单位则可以让段间距随字号变化而相应增大或缩小，示例如下： 12/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为30 像素*/p &#123;font-size:1em; margin:.75em 30px;&#125; 浮动与清除浮动CSS 设计float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性居然也成了创建多栏布局最简单的方式。 文本绕排图片：为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后再写环绕它的文本。示例如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; /*为简明起见，省略了字体声明*/ p &#123;margin:0; border:1px solid red;&#125; /*外边距防止图片紧挨文本*/ img &#123;float:left; margin:0 4px 4px 0;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="images/acoustic_nylon1.jpg" alt="nylon string acoustic guitar" /&gt; &lt;p&gt;Do you know，guitar?I very like guitar!It's my favorite a kind of instrument! If you don't know guitar,piease read this article.I believe the article will be very helpful to you! The guitar is used for various musical style, it in the pop music, rock music, r&amp;b, folk music, Buddha brother Ming is regarded as the main instrument. There are also in the guitar classical music, there have been a lot of solo, selects a use of and orchestra. It usually have six strings, but there are four strings, eight and ten strings, ten strings ErXian. There are two main categories: guitar ShiYou history, a wooden sound box with the timber guitar, 8031 ErShiEr 10th century were invented, electric guitars 8031. Loudspeakers Timber guitar is usually used to classical music, folk music and popular music. Guitars are often used to, rock music, blues and pop music. The invention of receiving of western pop culture and music had important influence. Now,do you learn guitar and love it?&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 结果如下所示： 浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。 2.创建分栏在此基础上创建多栏，只要再用一次float 属性，如下图所示，只要给段落设定宽度，然后也浮动它即可。 12p &#123;float:left; margin:0; width:300px; border:1px solid red;&#125;img &#123;float:left; margin:0 4px 4px 0;&#125; 结果如下： 围住浮动元素的三种方法如果出现下面的这种情况应该怎么办？底部的标题跑到右边去了 123section &#123;border:1px solid blue; margin:0 0 10px 0;&#125;img &#123;float:left;&#125;footer &#123;border:1px solid red;&#125; 结果如下： 方法一：为父元素添加overflow:hidden，以强制它包围浮动元素。 123section &#123;border:1px solid blue; margin:0 0 10px 0; overflow:hidden;&#125;img &#123;float:left;&#125;p &#123;border:1px solid red;&#125; 方法二：同时浮动父元素。 123section &#123;border:1px solid blue; float:left; width:100%;&#125;img &#123;float:left;&#125;footer &#123;border:1px solid red; clear:left;&#125; 这里注意：由于section浮动了，所有为了强制footer依然呆在section 下方，要给它应用clear:left。 方法三：添加非浮动的清除元素。强制父元素包含其浮动子元素的方法，就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。在包含元素最后添加子元素作为清除元素的方式有两种。第一种如下所示： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; section &#123;border:1px solid blue;&#125; img &#123;float:left;&#125; .clear_me &#123;clear:left;&#125; footer &#123;border:1px solid red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;img src="images/acoustic_nylon1.jpg" alt="nylon string acoustic guitar" /&gt; &lt;p&gt;It is fun to float.&lt;/p&gt; &lt;div class="clear_me"&gt;&lt;/div&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element…&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 第二种如下所示： 用CSS 来添加这个清除元素的方法，添加clearfix类 123456789101112131415#html 部分&lt;section class="clearfix"&gt; &lt;img src="images/rubber_duck.jpg"&gt; &lt;p&gt;It is fun to float.&lt;/p&gt;&lt;/section&gt;&lt;footer&gt; Here is the footer element…&lt;/footer&gt;## CSS样式.clearfix:after &#123;content:".";display:block;height:0;visibility:hidden;clear:both;&#125; 使用clear:both 意味着section 中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用left，但both 也适用于将来图片float:right 的情况。 定位CSS 布局的核心是position 属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。position 属性有4 个值：static(静态定位)、relative(相对定位)、absolute(绝对定位)、fixed(固定定位)，默认值为static。从完全移出文档流的角度说，固定定位与绝对定位类似。但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动 定位上下文把元素的position 属性设定为relative、absolute 或fixed 后，继而可以使用top、right、bottom 和left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。示例代码如下所示： 123456789&lt;body&gt; &lt;div id="outer"&gt; &lt;div id="inner"&gt;This is text…&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;#搭配下面的CSSdiv#outer &#123;width:250px; margin:50px 40px; border-top:3px solid red;&#125;div#inner &#123;position:absolute; top:10px; left:20px; background:#ccc;&#125; 显示属性正如所有元素都有position 属性，所有元素也都有display 属性。尽管display 属性的值有很多，但大多数元素display 属性的默认值不是block，就是inline 块级元素，比如段落、标题、列表等，在浏览器中上下堆叠显示。 行内元素，比如a、span 和img，在浏览器中左右并排显示，只有前一行没有空间时才会显示到下一行。 把块级元素变成行内元素（或者相反）的魔法如下： 1234/*默认为block*/p &#123;display:inline;&#125;/*默认为inline*/a &#123;display:block;&#125; 背景CSS中每个元素盒子都可以想象成由两个图层组成，元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image 属性），背景图片叠加在背景颜色之上 CSS背景属性CSS规定以下与背景相关属性： 12345678background-colorbackground-imagebackground-repeatbackground-positionbackground-sizebackground-attachmentbackground(简写属性)background-clip、background-origin、background-break（目前尚未得到广泛支持） 背景颜色：background-color 是背景属性中最简单的，通过它可以设定元素的颜色。然后，元素就会以设定的颜色填充背景图层。 1234567body &#123;background-color:#caebff;&#125;p &#123;/*盒子布局样式*/ font-family:helvetica, arial, sans-serif; font-size:18px; width:350px; margin:20px auto; padding:10px; /*这个例子中讨论背景和前景样式*/ background-color:#fff; color:#666; border:4px solid;&#125; 上例中body 的background-color 是蓝绿色，段落的background-color是白色，前景色color是灰色，前景色既影响文本，也影响边框。 背景图片默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域，背景图片来源方式如下所示： 1background-image:url(图片路径/图片文件名) 要改变默认的水平和垂直重复效果，可以修改background-repeat 属性；要改变背景图片的起点，可以修改background-position 属性。 背景重复：控制背景重复方式的background-repeat属性有4个值。默认值就是repeat，效果就是水平和垂直方向都重复，直至填满元素的背景区域为止。另外3个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y 和在任何方向上都不重复（或者说只让背景图片显示一次）的no-repeat。 background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景区域。 background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应背景区域。 背景位置：控制背景位置的background-position 属性，是所有背景属性中最复杂的。background-position 属性有5个关键字值，分别是top、left、bottom、right 和center，这些关键字中的任意两个组合起来都可以作为该属性的值background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点 12/*center center 的简化写法*/p#center &#123;background-position:center;&#125; #相当于background-position:center cetner background-position:center center 设定图片中心点与元素中心点重合，然后再向各个方向重复设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。 背景尺寸：background-size 是CSS3 规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给它设定的值及含义如下。 50%：缩放图片，使其填充背景区的一半。 100px 50px：把图片调整到100 像素宽，50 像素高。 cover：拉大图片，使其完全填满背景区；保持宽高比。 contain：缩放图片，使其恰好适合背景区；保持宽高比。 背景粘附：background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。background-attachment:fixed 最常用于给body元素中心位置添加淡色水印，让水印不随页面滚动而移动。实现这种效果的CSS 规则如下。 12345678body &#123; background-image:url(images/watermark.png); background-position:center; background-color:#fff; background-repeat:no-repeat; background-size:contain; background-attachment:fixed;&#125; 简写背景属性：background 属性可以用来设定所有背景相关的值。比如，前面那个backgroundattachment的例子使用简写的background 属性，可以写成这样一条规则： 1body &#123;background:url(images/watermark.png) center #fff no-repeat contain fixed;&#125; 声明中少写了哪个属性的值（比如没写no-repeat），就会使用相应属性的默认值（repeat）。 其他CSS3 背景属性background-clip: 控制背景绘制区域的范围，比如可以让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。默认情况下，背景绘制区域是扩展到边框外边界的。background-origin: 控制背景定位区域的原点，可以设定为元素盒子左上角以外的位置。比如，可以设定以内容区左上角作为原点。background-break: 控制分离元素（比如跨越多行的行内盒子）的显示效果。 多背景图片CSS3 还可以给元素背景添加多个背景图片，下面我们就使用简写属性background来说明 123456789101112p &#123; height:150px; width:348px; border:2px solid #aaa; margin:20px auto; font:24px/150px helvetica, arial, sansserif; text-align:center; background: url(images/turq_spiral.png) 30px -10px no-repeat, url(images/pink_spiral.png) 145px 0px no-repeat, url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75;&#125; 效果如下所示： 背景渐变渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。下面来看一个简单的线性渐变的例子，HTML 标记如下。 123&lt;div class='gradient1'&gt;&lt;/div&gt;&lt;div class='gradient2'&gt;&lt;/div&gt;&lt;div class='gradient3'&gt;&lt;/div&gt; CSS 规则如下。 1234567891011121314151617181920/*为元素盒子添加样式*/div &#123; height:150px; width:200px; border:1px solid #ccc; float:left; margin:16px;&#125;/*例1：默认为从上到下*/.gradient1 &#123;background:linear-gradient(#e86a43, #fff);&#125;/*例2：从左到右*/.gradient2 &#123;background:linear-gradient(left, #64d1dd, #fff);&#125;/*例3：左上到右下*/.gradient3 &#123;background:linear-gradient(-45deg, #e86a43, #fff);&#125; 下图展示了三种简单的渐变效果。例1 声明了一种开始属性和一种结束颜色，这两种颜色会按照默认的方向（从下到下）实现平滑过渡。例2 起点关键字left，于是渐变方向变成了从左到另一端。例3 声明了-45deg（deg 是“度”），等于把起点从默认的中上设定到了左上。]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标记与文档结构]]></title>
    <url>%2FBlog%2Fposts%2F10.html</url>
    <content type="text"><![CDATA[CSS的用途就是为HTML标记添加样式，所以，我们首先要先知道怎么编写和构造HTML标记，才能让CSS更方便地为它添加样式。用HTML标记内容的目的是为了赋予网页语义，我们平常用的浏览器、给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的Web爬虫都是用户代理，它们需要显示、朗读和分析网页。HTML规定了一组标签，用来给内容打上不同的标记，每个标签都是对所包含内容的一种描述，最常用的HTML标签描述的是标题、段落、链接和图片。目前，HTML一共有114个标签，但按照80/20的原则，使用其中25个左右的标签就可以满足80%的标记需要。在给内容都打上标记之后，就可以使用CSS来给标签添加样式了，添加样式的依据有标签名、标签属性（如id和class）、以及标签与其他标签在标记中的相对位置关系，等等。HTML标签也会构成一个层次化的文档，从而可以通过CSS来设置网页的布局，为每个元素应用你想要的样式。 HTML标记基础文本用闭合标签格式如下1&lt;标签名&gt;文本内容&lt;/标签名&gt; 标题、段落等文本元素都要求闭合标签，也就是要有一个开标签和一个闭标签 引用内容用自闭合标签格式如下1&lt;标签名 属性_1="属性值" 属性_n="属性值" /&gt; 非文本内容是通过自闭合标签显示的，比如图片等，闭合标签与自闭合标签的区别在于闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的引用。浏览器会在HTML页面加载的时候，额外想服务器发送请求，以取得自闭合标签引用的内容。下面就是使用自闭合标签标记的一张图片。 1&lt;img src="images/cisco.jpg" alt="My dog Cisco"&gt; 属性属性负责为浏览器提供有关标签的额外信息，比如说，前面例子中的&lt;img&gt;标签有两个属性，一个属性是src(source，来源)，属性值是cisco.jpg，这个属性定义了图片的来源是一个名为cisco.jpg的文件，另一个属性是alt(alternative，替代内容)，定义的是在图片因故未能加载成功时在屏幕上显示的文本。 视障用户使用的屏幕阅读器会大声读出alt属性的内容，因此一定要给&lt;img&gt;标签的这个alt属性添加让人一听（或一看）就能明白的内容。 标题与段落一般来说，网页都会以一个&lt;h1&gt;标签开头，其中的文本用于告诉读者这个网页是干什么的，然后用&lt;h2&gt;标记下一级内容，或许是一个副标题，然后才是&lt;h3&gt;，以此类推。&lt;h1&gt;不仅是最大最突出的标题（除非你用CSS缩小它的字号），搜索引擎也会将其视为仅次于&lt;title&gt;标签的另一个搜索关键词的来源。段落用于标记主要的文本内容，是所有文本元素中出场率最高的一个，简言之，只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。 复合元素HTML不仅规定了标题、图片和段落等基本的内容标记，还规定了用于创建列表、表格和表单等复杂用户界面组件的标记，这些就是所谓的复合元素，即它们是由多个标签共同完成的。比如，&lt;li&gt;是一个列表项，它只在&lt;ol&gt;(有序列表)和&lt;ul&gt;(无序列表)中才有效，在&lt;dl&gt;(定义列表)中则无效。如下所示： 12345&lt;ol&gt; &lt;li&gt;Save HTML file&lt;/li&gt; &lt;li&gt;Move file to Web server via FTP&lt;/li&gt; &lt;li&gt;Preview in browser&lt;/li&gt;&lt;/ol&gt; 结果如下图所示： 嵌套标签在上面的例子中，基于&lt;li&gt;标签与&lt;ol&gt;标签的嵌套关系，可以说&lt;li&gt;标签是&lt;ol&gt;标签的子标签（或子元素），或者说&lt;ol&gt;标签是&lt;li&gt;标签的夫标签（父元素）。**注意：在一个标签里嵌套另一个标签必须先关闭后一个标签再关闭前一个标签，示例如下： 1&lt;p&gt;That car is &lt;em&gt;fast&lt;/em&gt;.&lt;/p&gt; HTML文档的结构正是通过类似这样的标签嵌套，以及就此建立起来标签间的“父——子”关系形成的。 HTML文档剖析HTML模板按照HTML5语法编写的最简单的HTML页面的模板可以写成这样： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 这里是网页内容--&gt; &lt;/body&gt;&lt;/html&gt; 模板的第一行代码是一种新语法，或者说是一种简化的DOCTYPE，这一行就是为了声明： “以下是一个HTML文档。”这个标签不用关闭。&lt;html&gt;标签是根级标签，页面中所有的其他标签都嵌套在这个标签内部，而且它的闭标签也是整个页面中的最后一个闭标签，&lt;html&gt;标签只有两个直接的子标签：&lt;head&gt;和 &lt;body&gt;。 帮助浏览器理解页面的信息都包含在&lt;head&gt;标签中，在上面的例子中，&lt;head&gt;标签里只包含&lt;meta&gt;和&lt;title&gt;两个标签，其中&lt;meta&gt;标签中有一个charset属性，它是在告诉浏览器这个页面使用的是UTF-8编码，&lt;title&gt;标签的文本会在页面显示时，作为整个页面的标题出现在浏览器窗口顶部的标题栏中。&lt;body&gt;标签则包含着标记所有内容的HTML元素。 块级元素和行内元素下面介绍一些块级标签和行内标签： 1234567891011121314块级标签&lt;h1&gt;-&lt;h6&gt;: 6级标签，&lt;h1&gt;表示最重要&lt;p&gt;: 段落&lt;lo&gt;: 有序列表&lt;li&gt;：列表项&lt;blockquote&gt;: 独立引用行内标签&lt;a&gt;：链接（anchor，锚）&lt;img&gt;: 图片&lt;em&gt;：斜体&lt;strong&gt;：重要&lt;abbr&gt;：简写&lt;cite&gt;: 引证&lt;q&gt;: 文本内引用 几乎所有HTML元素的display属性值要么是block，要么是inline。最明显的一个例外是table元素，它有自己的display属性值。块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行，而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情况下才会折到下一行显示。 使用块级元素和行内元素构建页面： 示例如下 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Block and Inline Elements&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Types of Guitars&lt;/h1&gt; &lt;p&gt;Guitars come in two main types: electric and acoustic.&lt;/p&gt; &lt;h2&gt;Acoustic Guitars&lt;/h2&gt; &lt;p&gt;Acoustic guitars have a large hollow body that projects the sound of the strings.&lt;/p&gt; &lt;h3&gt;Nylon String Acoustic Guitars&lt;/h3&gt; &lt;p&gt;Descendants of the gut-strung instruments pf yore,nylon string guitars have a mellow tone.&lt;/p&gt; &lt;h2&gt;Electric Guitars&lt;/h2&gt; &lt;img src="images/acoustic_nylon.jpg" alt="nylon string acoustic guitar" /&gt; &lt;p&gt;Electric guitars have a solid or hollow body with pickups that capture the string vibration so it can be amplified.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 结果如下： 嵌套的元素嵌套标记实际上就是嵌套盒子，在后面CSS盒模型重点介绍 文档对象模型HTML结构所对应的文档对象模型（以下简称”DOM”）,DOM是从浏览器的视角观察页面中的元素以及每个元素的属性，由此得出这些元素的一个家族树，通过DOM可以确定元素之间的相互关系，在CSS中引用DOM中特定的位置，就可以选中响应的HTML元素，并修改其样式属性。示例如下： 123456&lt;body&gt; &lt;section&gt; &lt;h1&gt;The Document Object Model&lt;/h1&gt; &lt;p&gt;The page's HTMLmarkup structure defines the DOM.&lt;/p&gt; &lt;/section&gt;&lt;/body&gt; 对于这个例子中的DOM层次，我们可以做如下表述。 section是h1和p的父元素，也是直接祖先元素； h1和p是section的子元素，也是直接后代元素； h1和p是同胞元素，它们有共同的父元素section; section、h1和p是body的后代元素，或者下面的元素（嵌套在后者的内部）； section和body是h1和p的祖先元素，或者上面的元素（在某一层次上包含后者）。]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询]]></title>
    <url>%2FBlog%2Fposts%2F13.html</url>
    <content type="text"><![CDATA[媒体查询提供一种查询语法去扩展媒体类型，这种查询语法可以更加具体地为用户的设备提供样式，媒体查询可以给你一种自由，让网站真正地与设备无关，不管用户如何访问网站，都为它们提供最佳的合适体验。 媒体查询的优点媒体查询会基于设备的属性来检测设备，这样就不需要使用浏览器探测脚本，之后允许直接安装设备的功能区设定目标样式表，所以如果检测到用户适应小屏幕的设备，CSS规则就会调整以适应该屏幕尺寸，从屏幕上去掉无关元素，提供更小的图片，让文本变得更加清晰。 HTML&lt;link&gt;标签实例：链接一个外部样式表： 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="theme.css"/&gt;&lt;/head&gt; 在用于样式表时，&lt;link&gt;标签得到了几乎所有浏览器的支持，但是几乎没有浏览器支持其他方面的用途。定义和用法：&lt;link&gt; 标签定义文档与外部资源的关系。&lt;link&gt; 标签最常见的用途是链接样式表。HTML 与 XHTML 之间的差异: 第一种是使用&lt;link&gt;元素区调用一个外部样式表：在 HTML 中，&lt;link&gt; 标签没有结束标签。在 XHTML 中，&lt;link&gt; 标签必须被正确地关闭。提示和注释：注释：link 元素是空元素，它仅包含属性。注释：此元素只能存在于 head 部分，不过它可出现任何次数。属性：这里仅介绍HTML5中的新属性 属性 值 描述 href URL 规定被链接文档的位置。 hreflang language_code 规定被链接文档中文本的语言。 media media_query 规定被链接文档将被显示在什么设备上。 rel alternate 规定当前文档与被链接文档之间的关系。 author help icon licence next pingback prefetch prev search sidebar tag stylesheet sizes heightxwidth 规定被链接资源的尺寸。仅适用于 rel="icon"。 any type MIME_type 规定被链接文档的 MIME 类型。 全局属性 属性 描述 accesskey 规定激活元素的快捷键。 class 规定元素的一个或多个类名（引用样式表中的类） contenteditable 规定元素内容是否可编辑。 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 dir 规定元素中内容的文本方向。 draggle 规定元素是否可拖动。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。 id 规定元素的唯一 id。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。 translate 规定是否应该翻译元素内容。 语法媒体查询设置了一个参数（或者一系列参数），如果设备在查看页面的时候具有与该参数匹配的属性，就会显示与之相关的样式规则。有三种方式使用媒体查询，它们是和我们把CSS应用到文档中的不同方式相匹配的，第一种是使用一个link元素去调用一个外部样式表： 1&lt;link href="file" rel="stylesheet" media="logic media and (expression)"&gt; 第二种是使用@import指令调用外部的样式表： 1@import url('file') logic media and (expression); 第三种是在一个嵌入的style元素中或在样式表本身利用扩展的@media规则使用媒体查询： 1@media logic media and (expression) &#123; rules &#125;]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章 面向对象的程序设计]]></title>
    <url>%2FBlog%2Fposts%2F9.html</url>
    <content type="text"><![CDATA[ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或者函数。 理解对象创建自定义对象的最简单方式就是创建一个object的实例，然后再为它添加属性和方法，创建对象有两种方式，最常用的是对象字面量语法形式，如下所示： 12345678var person = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125; 属性类型ECMAScript中有两种属性：数据属性和访问器属性。数据属性：包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性，如下所示： 1234[[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，特性默认值为true；[[Enumerable]]: 表示能否通过for-in循环返回属性，特性默认值为true；[[Writable]]: 表示能否修改属性的值，特性默认值为true；[[Value]]: 包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置，特性默认值为undefined。 要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法，这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符对象的属性必须是：configurable、enumerable、writable和value，设置其中的一个或多个值，可以修改对应的特性值，例如： 123456789101112var person = &#123;&#125;;Object.defineProperty(person,"name",&#123; writable: false, configurable: false, value: "Nicholas"&#125;);console.log(person.name); //"Nicholas"person.name = "Greg";console.log(person.name); //"Nicholas"delete person.name;console.log(person.name); //"Nicholas" 访问器属性：访问器属性不包括数据值，它们包含一对儿getter和setter函数（不过，这两个函数都不是必须的），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下4个特性： 1234[[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，特性默认值为true；[[Enumerable]]: 表示能否通过for-in循环返回属性，特性默认值为true；[[Get]]: 在读取属性时调用的函数，默认值为undefined；[[Set]]: 在写入属性时调用的函数，默认值为undefined。 访问器属性同样不能直接定义，需要使用Object.defineProperty()来定义，如下所示： 12345678910111213141516171819var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book,"year",&#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if(newValue&gt;2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2015;console.log(book.edition); //12console.log(book._year); //2015 以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性，而访问器属性year则包含一个getter函数和一个setter函数，设置一个属性的值导致其他属性发生变化是使用访问器属性的常用方式。区别于python的访问限制。 定义多个属性Object.defineProperties() 方法可以通过描述符一次定义多个属性，这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应，实例如下： 1234567891011121314151617181920var book = &#123;&#125;;Object.defineProperties(book,&#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function() &#123; if(newValue&gt;2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;) 以上代码在book对外上定义了两个数据属性（_year和edition)和一个访问器属性（year）。最终的对象与上面例子中的定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。 读取属性的特性使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符，这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value 123456789101112131415161718192021222324var book = &#123;&#125;;Object.defineProperties(book,&#123; _year: &#123; value: 2004 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function() &#123; if(newValue&gt;2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book, "_year");console.log(descriptor.value); //2004console.log(descriptor.configurable); //false 创建对象工厂模式工厂模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下所示： 123456789101112131415function createPerson(name,age,job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor");console.log(person1);console.log(person2) 输出结果为： 12&#123; name: 'Nicholas', age: 29, job: 'Software Engineer', sayName: [Function] &#125;&#123; name: 'Greg', age: 27, job: 'Doctor', sayName: [Function] &#125; 函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次地调用这个函数，而且每次它都能返回一个包含三个属性一个方法的对象，解决了创建多个相似对象的问题，但是仍没有解决对象识别的为题（即怎样知道一个对象的类型）。 构造函数模式ECMAScript中的构造函数可用来创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，将前面工厂模式的例子重写成构造函数如下所示： 12345678910111213function Person(name,age,job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor");console.log(person1);console.log(person2) 输出结果与上面相同，Person()与createPerson()函数存在以下几点不同： 没有显示地创建对象； 直接将属性和方法赋给了this对象； 没有return语句 注意：构造函数的函数名按照惯例以大写字母开头，创建构造函数的新实例必须使用new操作符。 构造函数胜过工厂函数的地方就是创建自定义的构造函数可以将它的实例标识为一种特定的类型，如下所示： 1234console.log(person1 instanceof Object); //trueconsole.log(person1 instanceof Person); //trueconsole.log(person2 instanceof Object); //trueconsole.log(person2 instanceof Person) //true 将构造函数当作函数：构造函数与其他函数的唯一区别在于调用它们的方式不同，任何函数，只要通过new操作符来调用，就可以作为构造函数；如果不通过new操作符来调用，就是普通函数。如下面的例子所示： 123456789101112//当作构造函数使用var person = new Person("Nicholas", 29, "Software Engineer");person.sayName(); // "Nicholas"//作为普通函数调用Person("Greg", 27, "Doctor"); //添加到windowwindow.sayName(); //"Greg"//在另一个对象的作用域中调用var o = new Object();Person.call(o, "Keisten", 25, "Nurse");o.sayName(); //"Keisten" 构造函数仍然存在的一些问题：使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍，比如person1与person2都有一个名为sayName()方法，但不是同一个Function()的实例，也可以将方法转移到构造函数之外，定义在全局作用域上，但是这样就没有封装性可言了。 1console.log(person1.sayName == person2.sayName) //false 原型模式我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，就是不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下所示： 123456789101112131415function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person();person2.sayName(); //"Nicholas"console.log(person1.sayName == person2.sayName); //true 新对象的这些属性和方法是由所有实例共享的，即person1和person2访问的都是同一组属性和同一个sayName()函数，因此要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。 理解原型对象: 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，其他方法都是从Object继承而来的，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。这个指针叫[[Prototype]]。以前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。 上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示： 12console.log(Person.prototype.isPrototypeOf(person1)); //trueconsole.log(Person.prototype.isPrototypeOf(person2)); //true Object.getPrototypeOf()方法返回[[Prototype]]的值 12console.log(Object.getPrototypeOf(person1) == Person.prototype); //trueconsole.log(Object.getPrototypeOf(person1).name) //"Nicholas" 注意：虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果在实例中添加了一个属性，而该属性与原型中的一个属性同名，则在实例中创建该属性，该属性会屏蔽掉原型中的那个属性。 原型与in操作符: 有两种方式使用in操作符：单独使用和在for-in循环中使用，在单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。hasOwnProperty()只在属性存在于实例中才返回true，当同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中还是存在于原型中，如下所示： 123456789101112131415161718function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();person1.name = "Greg";console.log(person1.hasOwnProperty("name")); //trueconsole.log("name" in person1); //trueconsole.log(person2.hasOwnProperty("name")); //falseconsole.log("name" in person2); //true 在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括于存在于实例中的属性，也包括存在于原型中的属性，屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性）的实例属性也会在for-in循环中返回。使用ECMAScript5的Object.keys()方法能取得对象上所有可枚举的实例属性，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。 1234567891011function Person() &#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;;var keys = Object.keys(Person.prototype);console.log(keys); //[ 'name', 'age', 'job', 'sayName' ] 如果要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法 1var keys = Object.getOwnPropertyNames(Person.prototype); //[ 'constructor', 'name', 'age', 'job', 'sayName' ] 更简单的原型语法: 前面例子中每一个属性和方法就要敲一遍Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，因此用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下例所示： 1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123; name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;;var friend = new Person();console.log(friend instanceof Object); //trueconsole.log(friend instanceof Person); //trueconsole.log(friend.constructor == Person); //falseconsole.log(friend.constructor == Object); //true 原型的动态性: 由于在原型中查找值的过程是一次搜索，因此我们对原型对象的所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。如下面的例子所示： 12345678function Person () &#123;&#125;var friend = new Person();Person.prototype.sayHi = function() &#123; console.log("hi");&#125;;friend.sayHi(); //"hi" 即使Person实例friend是在添加新方法之前创建的，但它仍然可以访问这个新方法，其原因可以归结于实例与原型之间的松散连接关系，当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型，因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，情况就会不同，调用构造函数时回味实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系，实例中的指针仅指向原型，而不指向构造函数。 1234567891011121314function Person () &#123;&#125;var friend = new Person();Person.prototype = &#123; consttructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", sayName: function() &#123; console.log(this.name); &#125;&#125;;friend.sayHi(); //error:friend.sayHi is not a function 原生对象的原型: 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的，所有原生引用类型（Object、Array、String等等）都在其构造函数上定义了方法，如下所示： 12console.log(typeof Array.prototype.sort); //functionconsole.log(typeOf String.prototype.substring); //function 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。比如下面的例子： 12345String.prototype.startsWith = function (text) &#123; return this.indexOf(text) == 0;&#125;;var msg = "Hello World";console.log(msg.startsWith("Hello")); //true 原型对象的问题: 1.原型对象省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值2.原型中所有属性是被很多实例共享的，这种共享对于函数非常合适，但是对于包含引用类型值的属性来说，问题就突出了，如下所示： 1234567891011121314151617181920function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: "Nicholas", age: 29, job: "Software Engineer", friends: ["Shelby", "Court"], sayName: function() &#123; console.log(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push("Van");console.log(person1.friends); //[ 'Shelby', 'Court', 'Van' ]console.log(person2.friends); //[ 'Shelby', 'Court', 'Van' ]console.log(person1.friend == person2.friend); ////true 上面的问题是很少有人单独使用原型模式的原因所在。 组合使用构造函数模式与原型模式创造自定义函数的最常见方式，就是组合使用构造函数和原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存；另外，这种混成模式还支持向构造函数传递参数，可谓是集两种模式之长。如下例所示： 12345678910111213141516171819202122function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friends = ["Shely", "Court"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 25, "Doctor");person1.friends.push("Van");console.log(person1.friends); //[ 'Shely', 'Court', 'Van' ]console.log(person2.friends); //[ 'Shely', 'Court' ]console.log(person1.friends === person2.friends); //falseconsole.log(person1.sayName === person2.sayName); //true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的，修改person1.friend（向其中传入一个新字符串），并不会影响到person2.friends，因为它们分别引用了不同的数组。这种构造函数与原型模式混合的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法，可以说，这是用来定义引用类型的一种默认模式。 动态原型模式动态原型模式是针对独立的构造函数和原型产生的，动态原型模式将所有信息都封装在构造函数中，通过在构造函数中初始化原型（仅在必要的条件下），又保持了同时使用构造函数和原型的优点，换句话说，可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。如下例： 123456789101112131415function Person(name,age,job) &#123; // 属性 this.name = name; this.age = age; this.job = job; // 方法 if(typeof this.sayName != "function") &#123; Person.prototype.sayName = function() &#123; console.log(this.name); &#125; &#125;&#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); // "Nicholas" 寄生构造函数模式若是前面几种模式都不适用，可以选择使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用是封装对象的代码，然后再返回新创建的对象，但是从表面来看，这个函数又很像是典型的构造函数，但是除了使用new操作符并把使用的函数叫做构造函数之外，这个模式其实和工厂模式是一模一样的。 12345678910111213function Person(name,age,job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; console.log(this.name); &#125;; return o;&#125;var friend = new Person("Nicholas", 29, "Software Engineer");friend.sayName(); //"Nicholas" **这个模式可以在特殊的情况下用来为对象创建构造函数，假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式。如下例所示： 123456789101112131415function SpecialArray() &#123; // 创建数组 var values = new Array(); // 添加值 values.push.apply(values,arguments); // 添加方法 values.toPipeString = function() &#123; return this.join("|"); &#125; // 返回数组 return values;&#125;var colors = new SpecialArray("red", "blue", "green");console.log(colors.toPipeString()); //"red|blue|green" 稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象，稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this，二是不使用new操作符调用构造函数，按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下： 12345678910111213function Person(name,age,job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; console.log(name); &#125;; // 返回对象 return o;&#125;var friend = Person("Nicholas", 29, "Software Engineer");friend.sayName(); //"Nicholas" 继承许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法，由于ECMAScript函数没有签名，因此无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 原型链原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，实现原型链有一种基本模式，其代码大致如下 1234567891011121314151617function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;function SubType() &#123; this.subproperty = false;&#125;// 继承了SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSuperValue()); //"true" 以上代码定义了两个类型：SuperType和SubType，每个类型分别有一个属性和一个方法，它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的，实现的本质是重写原型对象，代之以一个新类型的实例。调用原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.getSuperValue，最后一步找到该方法，在找不到属性或者方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。 别忘记默认的属性：所有的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype，这也是所有自定义类型都会继承toString()、valueof()等默认方法的根本原因，即上面的例子展示的原型链还应该包括另外一个继承层次。 确定原型与实例的关系：可以通过两种方式来确定原型和实例之间的关系，第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。如下所示： 123console.log(instance instanceof Object); //"true"console.log(instance instanceof SuperType); //"true"console.log(instance instanceof SubType); //"true" 第二种方法是使用isPrototypeOf()方法，同样只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示： 123console.log(Object.prototype.isPrototypeOf(instance)); //"true"console.log(SuperType.prototype.isPrototypeOf(instance)); //"true"console.log(SubType.prototype.isPrototypeOf(instance)); //"true" 谨慎地定义方法： 子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。 在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。 原型链的问题：原型链虽然很强大，可以用它来实现继承，但它也存在一些问题，其中，最重要的问题来自包含引用类型值的原型。如下所示： 12345678910111213function Supertype() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123;&#125;SubType.prototype = new Supertype();var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors); //[ 'red', 'blue', 'green', 'black' ]var instance2 = new SubType();console.log(instance2.colors) //[ 'red', 'blue', 'green', 'black' ] 当SubType通过原型链继承了Supertype之后，SubType.prototype就变成了Supertype的一个实例，因此它也拥有了一个它自己的colors属性，就跟专门创建了一个SubType.prototype.colors属性一样，结果是SubType的所有实例都会共享这一个colors属性。原型链的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。基于以上两个问题，实践中很少单独使用原型链。 借用构造函数在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数的技术（有时也叫做伪造函数或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。**而且函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数，如下所示： 12345678910111213function Supertype() &#123; this.colors = ["red", "blue", "green"];&#125;function SubType() &#123; // 继承了Supertype Supertype.call(this);&#125;var instance1 = new SubType();instance1.colors.push("black");console.log(instance1.colors);var instance2 = new SubType();console.log(instance2.colors) 代码中Supertype.call(this)“借调”了超类型的构造函数，通过使用call()方法（或apply()方法），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了Supertype构造函数，这样在新SubType对象上执行SubType()函数中定义的所有对象初始化代码，结果SubType的每个实例就会有自己的colors属性的副本了。 传递参数：相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。如下所示： 12345678910function Supertype(name) &#123; this.name = name;&#125;function SubType() &#123; Supertype.call(this, "Nicholas"); this.age = 29;&#125;var instance = new SubType();console.log(instance.name); //"Nicholas"console.log(instance.age); //29 借用构造函数的问题：如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数复用就无从谈起了，而且在超类型的原型中定义的方法对于类型而言也是不可见的，结果所有类型都只能使用构造函数模式，考虑到这些，借用构造函数的技术也是很少单独使用的。 组合继承组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，主要思想是使用原型链是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 引用类型]]></title>
    <url>%2FBlog%2Fposts%2F8.html</url>
    <content type="text"><![CDATA[引用类型的值（对象）是引用类型的一个实例，在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 1var person = new Object(); 这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型（例如Object），以便开发人员用以实现常见的计算任务。 Object 类型创建Object类型的方式有两种，第一种是使用new操作符后跟Object构造函数，如下所示： 123var person = new Object();person.name = "Nicholas";person.age = 29; 另一种方法是使用对象字面量的方法，如下所示： 1234var person = &#123; name: "Nicholas", age: 29&#125; 关于对象字面量语法，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示： 123var person = &#123;&#125; // 与new Object()相同person.name = "Nicholas";person.age = 29; **开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。 访问对象属性有两种办法：点表示法和方括号表示法 12console.log(person["name"]); // "Nicholas"console.log(person.name); // "Nicholas" 从功能上看，这两种访问对象属性的方法没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性，例如： 12var propertyName = "name";console.log(person[propertyName]); // "Nicholas" 如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法，例如： 1person["first name"] = "Nicholas"; Array 类型Array类型与Object类型一样都是ECMAScript中最常用的类型，ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据，创建数组的基本方式有两种，第一种是使用Array构造函数，如下所示： 1var colors = new Array(); 创建数组也可以按照下面几种方式进行创建： 1234var colors = new Array(20); // 创建length为20的数组var colors = new Array("red", "blue", "green"); // 创建了一个包含三个字符串值的数组var colors = new Array(3); // 创建一个包含3项的数组var colors = new Array("Grey"); // 创建一个包含1项，即字符串"Grey"的数组 在使用Array构造函数时也可以省略new操作符，省略new操作符与不省略new操作符的结果相同。 创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示： 1234var colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组var name = []; // 创建一个空数组var values = [1,2,]; // 不要这样！这样会创建一个包含2项或3项的数组var options = [,,,,,]; // 不要这样！这样会创建一个包含5项或6项的数组 在读取和设置数组的值时，要使用方括号并提供响应值的基于0的数字索引，如下所示： 12345var colors = ["red", "blue", "green"]; // 定义一个字符串数组console.log(color[0]); // 显示第一项color[2] = "black"; // 修改第三项color[3] = "brown"; // 新增第四项console.log(colors.length); // 4 上面例子的数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除或向数组中添加新项，如下所示： 123var colors = ["red", "blue", "green"];colors.length = 2;console.log(colors[2]); // undefined 下面介绍数组会用到的一些方法 检测数组方法ECMAScript新增Array.isArray()方法，这个方法能确定某个值最终到底是不是数组，不管在哪个全局环境下创建的。 123if (Array.isArray(value)) &#123; // 对数组执行某些操作&#125; 转换方法数组继承的toString()返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串，valueOf()返回的还是数组。使用join()方法，则可以使用不同的分隔符来构建字符串，join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 1234var colors = ["red", "blue", "green"];console.log(colors.toString());console.log(colors.valueOf());console.log(colors.join("||")); 输出结果如下： 123red,blue,green[ 'red', 'blue', 'green' ]red||blue||green 栈方法ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；pop()方法则从数组末尾移除最后一项，减少数组的length()值，然后返回移除的项。 12345678910var colors = new Array();var count = colors.push("red", "green");console.log(count); //2count = colors.push("black");console.log(count); //3var item = colors.pop();console.log item; //"black"console.log(colors.length); //2 队列方法实现这一操作的方法有两组：从数组末端添加项，从数组前端取得项：push()与shift()方法从数组前端添加项，从数组末端取得项：unshift()与pop()方法 12345678910var colors = new Array();var count = colors.push("red", "green");console.log(count); //2count = colors.push("black");console.log(count); //3var item = colors.shift();console.log(item); //"red"console.log(colors.length); //2 这个例子创建了一个数组并使用push()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”red”,”green”,”black”，在调用shift()方法时，移除并返回的是第一项，即”red”。 12345678910var colors = new Array();var count = colors.unshift("red", "green");console.log(count); //2count = colors.unshift("black");console.log(count); //3var item = colors.pop();console.log(item); //"green"console.log(colors.length); //2 这个例子创建了一个数组并使用unshift()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”black”,”red”,”green”，在调用pop()方法时，移除并返回的是最后一项，即”green”。 重排序方法reverse()方法：反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();console.log(values); //5,4,3,2,1 sort()方法：按照升序或者降序顺序排列数组项，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，然后接收一个比较函数作为参数，以确定排列顺序。示例如下：这个示例是按照升序进行排列的，若是按照降序排列，只需交换比较函数返回的值即可。 123456789101112function compare(value1,value2) &#123; if(value1 &lt; value2) &#123; return -1; &#125;else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var values = [0,1,5,10,15];values.sort(compare);console.log(values)； // 0，1，5，10，15 操作方法要介绍的concat()方法、slice()方法都不影响原始数组。concat()方法：可以基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 12345var colors1 = ["red", "green", "blue"];var colors2 = colors1.concat("yellow", ["black", "brown"]);console.log(colors1); // red,green,blueconsole.log(colors2); // red,green,blue,yellow,black,brown slice()方法：能够基于当前数组中的一个或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；如果有两个参数，该方法返回起始和结束位置之间的项但不包括结束位置的项。 123456var colors1 = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors1.slice(1);var colors3 = colors1.slice(1,4);console.log(colors2); // green,blue,yellow,purpleconsole.log(clolors3); // green,blue,yellow splice()方法：该方法包括对原始数组的删除、插入以及替换功能 删除：可以删除任意数量的项，只需提供2个参数：要删除的第一项的位置和要删除的项数； 插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项； 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项，插入的项不必等于删除的项数。实例如下所示： 123456789101112var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); // 删除第一项console.log(colors); // green,blueconsole.log(removed); // redremoved = colors.splice(1,0,"yellow", "orange"); // 从位置1开始插入两项console.log(colors); // green,yellow,orange,blueconsole.log(removed); // 返回的是一个空数组removed = colors.splice(1,1,"red", "purple"); // 插入两项，删除一项console.log(colors); // green,red,purple,orange,blueconsole.log(removed); // yellow 位置方法ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()方法，这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1，在比较第一个参数与数组中的每一项时，使用全等操作符（===） 12345678910111213var colors = new Array("red", "blue", "green", "black", "blue", "purple");console.log(colors.indexOf("blue"); // 1console.log(colors.indexOf("blue",2); // 4console.log(colors.latIndexOf("blue"); // 4console.log(colors.indexOf("yellow"); // -1#比较时全等var str1 = new String("blue");var str2 = "blue";console.log(typeof(str1)); // objectconsole.log(typeof(str2)); // stringconsole.log(colors.indexOf(str1)); // -1console.log(colors.indexOf(str2)); // 1 迭代方法ECMAScript提供了5个迭代方法，每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值,传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。以下方法都不会修改数组中的包含的值。 every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。 filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。 forEach()：对数组中的每一项运行给定函数，这个方法没有返回值。 map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。实例如下： 123456789101112131415161718192021222324252627var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123; return (item &gt; 2);&#125;)console.log(everyResult); // falsevar someResult = numbers.some(function(item,index,array)&#123; return (item &gt; 2);&#125;)console.log(someResult); // truevar filterResult = numbers.filter(funvtion(item,index,array)&#123; rerurn (item &gt; 2);&#125;)console.log(filterResult); // [3,4,5,4,3]var mapResult = numbers.map(function(item,index,array)&#123; return item * 2;&#125;)console.log(mapResult); // [2,4,6,8,10,8,6,4,2]numbers.forEach(function(item,index,array&#123; // 执行某些操作，这个方法没有返回值，本质上与for循环迭代数组一样&#125;)) 缩小方法ECMAScript5新增了两个缩小数组的方法：reduce()和reduceRight()。这两个数组都会迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后；reduceRight()则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值，传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数就是数组的第一项，第二个参数就是数组的第二项。使用reduce()方法可以执行求数组中所有值之和的操作，如下所示： 12345var values = [1,2,3,4,5];var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur;&#125;)console.log(sum); // 15 reduceRight()的作用类似，只不过方向相反而已。 Date类型ECMAScript中的Date类型是在早期Java中的java.utip.Date类基础上构建的，为此，Date类型使用自UTC1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。要创建一个日期对象，使用new操作符和Date构造函数即可，如下所示： 1var now = new Date(); 在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数，为了简化这一计算，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。Date.parse()是Date对象的静态方法，parse()方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。语法如下： 1Date.parse(datestring) UTC() 方法可根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。Date.UTC() 是一种静态方法，因为需要使用构造函数 Date() 来调用它，而不是通过某个 Date 对象调用。 Date.UTC() 方法的参数指定日期和时间，它们都是 UTC 时间，处于 GMT 时区。指定的UTC时间将转换成毫秒的形式，这样构造函数 Date() 和方法 Date.setTime() 就可以使用它了。语法如下： 1Date.UTC(year,month,day,hours,minutes,seconds,ms) 继承方法与其他引用类型一样，Date类型也重写了toLocalString()、toString()和valueOf()方法，但这些方法返回的值与其他类型中的方法不同。Date()类型的toLocalString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，这大致意味着时间格式中会包含AM或PM，但不会包含时区信息；而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。Date类型的valueOf()方法则根本不返回字符串，而是返回日期的毫秒表示。 日期格式化方法 toDateString(): 以特定实现的格式显示星期几、月、日和年； toTimeString(): 以特定于实现的格式显示时、分、秒和时区； toLocalTimeString(): 以特定于实现的格式显示时、分、秒； toLocalDateString(): 以特定于地区的格式显示星期几、月、日和年； toUTCString(): 以特定于实现的格式显示完整的UTC日期。 还有很多关于日期的函数方法： 更多参考：Date对象方法 RegExp类型ECMAScript通过RegExp类型来支持正则表达式 1var expression = /pattern/flags; 其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标名正则表达式的行为，正则表达式的匹配模式支持下列3个标志： g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； i: 表示不区分大小写模式，，即在确定匹配项时忽略模式与字符串的大小写； m: 表示多行模式，即在到达一行文末末尾时还会继续查找下一行中是否存在与模式匹配的项。因此一个正则表达式就是一个模式与上述3个标志的组合体，不同组合产生不同结果，如下面的例子所示： 1234567891011121314/* * 匹配字符串中所有"at"的实例 */var patttern1 = /at/g;/* * 匹配第一个"bat"或者"cat"，不区分大小写 */var patttern2 = /[bc]at/i;/* * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写 */var patttern3 = /.at/gi; 与其他语言中的正则表达式一样，模式中所使用的所有元字符都必须转义，正则表达式中的元字符包括： 1( | &#123; \ ^ $ ) ? * + . ]&#125; 这些元字符在正则表达式中都有一或多种特殊用途，因此想要匹配字符串中包含的这些字符，就必须对它们进行转义，下面给出几个例子： 12345678910111213141516171819/* * 匹配第一个"bat"或"cat"，不区分大小写 */var pattern1 = /[bc]at/i;/* * 匹配第一个"[bc]at"，不区分大小写 */var pattern2 = /\[bc\]at/i;/* * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写 */var patttern3 = /.at/gi;/* * 匹配字符串中所有以".at"结尾的3个字符的组合，不区分大小写 */var patttern4 = /\.at/gi; 前面举得这些例子都是以字面量形式来定义的正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串，可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示： 123456789/* * 匹配第一个"bat"或"cat"，不区分大小写 */var pattern1 = /[bc]at/i;/* * 与pattern1相同，只不过是使用构造函数创建的 */var pattern2 = new RegExp("[bc]at", "i"); 使用正则表达式字面量和使用RegExp构造函数创建的正则表达式u不一样，在ECMAScript3 中，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。如下所示： 123456789var re = null,i;for (i=0; i&lt;10; i++) &#123; re = /cat/g; console.log((re.text("catastrophe")));&#125;for (i=0; i&lt;10; i++)&#123; re = new RegExp("cat", "g"); console.log(re.text("catastrophe"));&#125; 在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例，由于实例属性不会重置，所以在循环中再次调用text()方法会失败，这是因为第一次调用text()找到了”cat”，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以就找不到它了，由于会测试到字符串末尾，所以下一次再调用text()就又从开头开始了。第二个循环使用RegExp构造函数在每次循环中创建正则表达式，因为每次迭代都会创建一个新的RegExp构造函数一样，每次创建新的RegExp实例。 RegExp实例属性RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。 global: 布尔值，表示是否设置了g标志； ignoreCase: 布尔值，表示是否设置了i标志； lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起； multiline: 布尔值，表示是否设置了m标志； source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。实例如下所示： 12345678910111213var pattern1 = /\[bc]at/i;console.log(pattern1.global); //falseconsole.log(pattern1.ignoreCase); //trueconsole.log(pattern1.lastIndex); //0console.log(pattern1.multiline); //falseconsole.log(pattern1.source); //"\[bc]at"var pattern2 = new RegExp("\\[bc\\]at", "i");console.log(pattern2.global); //falseconsole.log(pattern2.ignoreCase); //trueconsole.log(pattern2.lastIndex); //0console.log(pattern2.multiline); //falseconsole.log(pattern2.source); //"\[bc]at" RegExp实例方法RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。返回的数组包含两个额外的属性：index与input属性，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有匹配组，则该数组只包含一项）实例如下： 123456789var text = "mom and dad and baby";var pattern = /mom(and dad(and baby)?)?/gi;var matches = pattern.exec(text);console.log(matches.index); // 0 与整个模式匹配的字符串的第一项的位置console.log(matches.input); // "mom and dad and baby" 与整个模式匹配的字符串console.log(matches[0]); // "mom and dad and baby" 整个字符串本身的匹配项console.log(matches[1]); // "and dad and baby" 与第一个捕获组匹配的内容console.log(matches[2]); // "and baby" 与第二个捕获组匹配的内容 对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项，在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。如下面例子所示： 1234567891011121314151617181920212223var text = "cat,bat,sat,fat"// 非全局模式下：var pattern1 = /.at/;var matches = pattern1.exec[text];console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern1.lastIndex); //0// 每次调用exec()返回的都是第一个匹配项("cat")matches = pattern1.exec[text];console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern1.lastIndex); //0var pattern2 = /.at/g;var matches = pattern2.exec[text];console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern2.lastIndex); //4// 每次调用exec()返回的都是下一个匹配项，直到搜索到字符串末尾为止matches = pattern1.exec[text];console.log(matches.index); //0console.log(matches[0]); //batconsole.log(pattern2.lastIndex); //8 正则表达式的第二个方法是test(),它接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便，因此test()方法经常被用在if语句中。 12345var text = "000-00-0000";var pattern = /\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/;if(pattern.test(text))&#123; console.log("这个模式有匹配项")&#125; RegExp构造函数属性RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化，并且这些属性可以以两种方式访问，下表列出了RegExp构造函数的一些属性 长属性名 短属性名 说明 input $_ 最近一次要匹配的字符串，Opera未实现此属性 lastMatch $&amp; 最近一次的匹配项，Opera未实现此功能 lastParen $+ 最近一次匹配的捕获组，Opera未实现此属性 leftContext $` input字符串中lastMatch之前的文本 mulitiline $* 布尔值，表示是否所有表达式都是使用多行模式，IE和Opera未实现此属性 rightContext $’ input字符串中lastMatch之后的文本 使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息，例子如下： 123456789var text = "this has been a short summer";var pattern = /(.)hort/g;if(pattern.test(text))&#123; console.log(RegExp.input); // this has been a short summer console.log(RegExp.lastMatch); //short console.log(RegExp.leftContext); //this has been a console.log(RegExp.rightContext); //summer console.log(RegExp.mulitiline); //false&#125; 还可以通过短属性来访问它们，这里就不介绍了，与长属性用法相同 除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性，访问这些属性的方法是RegExp.$1、RegExp.$2 … RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组，在调用exec()或test()方法时，这些属性会被自动填充，如下所示： 123456var text = "this has been a short summer"var pattern = /(..)or(.)/g;if(pattern.test(text))&#123; console.log(RegExp.$1); //sh console.log(RegExp.$2); //t&#125; Function 类型函数是对象，函数名是一个指向函数对象的指针，不会与某个函数绑定，函数声明定义形式如下： 123function sum (num1,num2)&#123; return num1 + num2;&#125; 函数没有重载12345678function addSomeNumber(num) &#123; reurn num +100;&#125;function addSomeNumber(num) &#123; reurn num +200;&#125;var result = addSomeNumber(100); //300 第二个函数覆盖了第一个函数的变量，函数没有重载 函数声明与函数表达式解析器在向执行环境中加载数据时，会先读取函数声明，并使其在执行任何代码之前可用（可以访问），而函数表达式是等到解析器执行到它所在的代码行，才会真正被解释执行。如下所示： 1234console.log(sum(20,20));function sum(num1,num2)&#123; return num1 +num2;&#125; 解析器通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中，就是sum函数已经提前声明，所以可以在前面调用 作为值的函数可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回，如下所示： 123function callSomeFunction(someFunction, someArgument)&#123; return someFunction(someArgument);&#125; 函数内部属性函数内部有3个特殊的对象：arguments、this和caller。arguments是一个类数组对象，包含着传入函数中的所有参数，除此之外arguments还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数；如下递归阶乘函数所示： 1234567function factorial(num) &#123; if(num&lt;=1) &#123; return 1; &#125; else &#123; return num*arguments.callee(num-1) &#125;&#125; this引用的是函数执行的环境对象，在全局作用域中，this对象引用的是window。比如下面的例子： 12345678window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); //"red"o.sayColor = sayColor;o.sayColor(); //"blue" 第一次调用sayColor()是在全局作用域中定义的，this引用的对象是window，所以输出为”red”, 第二次this引用的对象是0，所以this.color= o.color, 返回为”blue”caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，会为null。示例如下： 1234567function outer() &#123; inner();&#125;function inner() &#123; console.log(arguments.calle.caller);&#125;outer(); 函数属性和方法由于ECMAScript中的函数是对象，所以函数也有属性和方法，每个函数有两个属性：length和prototypelength表示函数希望接收的命名参数的个数，prototype指的函数的原型方法，toString()、valueOf()等都属于prototype内。每个函数也会包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，其中，第二个参数可以是Array的实例，也可以是arguments对象。如下面的例子所示： 123456789101112function sum(num1,num2) &#123; return num1 + num2;&#125;function callSum1(num1,num2) &#123; return sum.apply(this,arguments);&#125;function callSum2(num1,num2) &#123; return sum.apply(this,[num1,num2]);&#125;console.log(callSum1(10,10)) //20console.log(callSum2(10,10)) //20 call()与apply()的作用没有什么不同，只是call()必须将传递给函数的参数逐个列举出来，如下面例子所示： 1234567function sum(num1,num2) &#123; return num1 + num2;&#125;function callSum(num1,num2) &#123; return sum.call(this,num1,num2);&#125;console.log(callSum(10,10)) //20 传递参数并非apply()和call()的真正用武之地，它们真正强大的地方是能扩充函数赖以运行的作用域，示例如下： 12345678window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor.call(this); //"red"sayColor.call(window); //"red"sayColor.call(o); //"blue" ECMAScript5还定义了一个方法：bind(),这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，例如： 12345678window.color = "red";var o = &#123;color: "blue"&#125;;function sayColor() &#123; console.log(this.color);&#125;var objectSayColor = sayColor.bind(o);objectSayColor(); //"blue" String类型字符方法charAt()与chaeCodeAt()方法，这两个方法都接收一个参数，即基于0的字符位置，charAt()方法以单字符串的形式返回给定位置的那个字符，chaeCodeAt()返回的是给定位置的字符编码 123var stringValue = "hello world"；console.log(stringValue.charAt(1)); //"e"console.log(stringValue.与chaeCodeAt(1)); //"101" 字符串操作方法concat()：用于将一或多个字符串拼接起来 1234var stringValue = "hello ";var result = stringValue.concat("world", "!");console.log(result); //"hello world!"console.log(stringValue) //"hello " 创建新字符串的三种方法：都接受一到两个参数slice()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束substring()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束substr()： ：第一个参数用于指定字符串的开始位置，第二个参数表示返回的字符个数 12345678var stringValue = "hello world";console.log(stringValue.slice(3)); //"lo world"console.log(stringValue.substring(3)); //"lo world"console.log(stringValue.substr(3)); //"lo world"console.log(stringValue.slice(3,7)); //"lo w"console.log(stringValue.substring(3,7)); //"lo w"console.log(stringValue.substr(3,7)); //"lo worl" 字符串位置方法有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()，这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该字符串，则返回-1），indexOf()方法是从字符串的开头向后搜索子字符串，而和lastIndexOf()方法是从字符串的末尾向前搜索子字符串。同时这两个方法都可以接收第二个参数，表示从字符串的哪个位置开始搜索。因此可以通过循环调用indexOf()和lastIndexOf()来找到所有匹配的子字符串。如下所示： 123456789var stringValue = "hello world,helo,dsjfkgsdlfkglfd";var positions = new Array();var pos = stringValue.indexOf("e");while(pos&gt;-1)&#123; positions.push(pos); pos = stringValue.indexOf("e", pos+1);&#125;console.log(positions); // [ 1, 13 ] trim()方法trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，示例如下： 123var stringValue = " hello world ";var trimstringValue = stringValue.trim();console.log(trimstringValue); // "hello world" 字符串大小写转换方法字符串大小写转换方法有toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。toLowerCase()与toUpperCase()是通用方法，toLocaleLowerCase()与toLocaleUpperCase()是针对特定地区的实现，一般来说不知道自己的代码将在哪种语言运行环境下运行的时候，还是使用针对地区的方法更稳妥一些，示例如下： 12345var stringValue = "Hello World"console.log(stringValue.toLowerCase());console.log(stringValue.toLocaleLowerCase());console.log(stringValue.toUpperCase());console.log(stringValue.toLocaleUpperCase()); 输出结果如下： 1234hello worldhello worldHELLO WORLDHELLO WORLD 字符串的模式匹配方法match(): 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象。示例如下： 123456var text = "cat,bat,sat,fat"var pattern = /.at/;var matches = text.match(pattern);console.log(matches.index); //0console.log(matches[0]); //catconsole.log(pattern.lastIndex); //0 search()：这个方法返回字符串中的第一个匹配项的索引，如果没有找到匹配项，则返回-1，这个方法的唯一参数与match()方法相同。如下所示： 1234var text = "hello,bat,sat,fat"var pattern = /.at/;var pos = text.search(pattern);console.log(pos); //6 replace()方法：这个方法接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的方法就是提供一个正则表达式，而且要指定全局（g）标志。如下所示： 123var text = "cat,bat,sat,fat"var result = text.replace(/at/g,"12");console.log(result); 结果如下： 1c12,b12,s12,f12 replace()方法的第二个参数也可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。如下所示： 123456789101112131415function himlEscape(text) &#123; return text.replace(/[&lt;&gt;"&amp;]/g, function(match,pos,originalText)&#123; switch(match) &#123; case "&lt;": return "&amp;lt;"; case "&gt;": return "&amp;gt;"; case "&amp;": return "&amp;amp;"; case "\"": return "&amp;quot" &#125; &#125;);&#125;console.log(himlEscape("&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;")); #&amp;lt;p class=&amp;quotgreeting&amp;quot&amp;gt;Hello World!&amp;lt;/p&amp;gt; split()方法：这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会讲字符串看成正则表达式），split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回额数组不会超过既定大小。如下例所示： 123var colorText = "red,blue,green,yellow";var color = colorText.split(",");console.log(color); //["red","blue","green","yellow"] localeCompare()方法与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：1、如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况是-1）；2、如果字符串等于字符串参数，则返回0；3、如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。示例如下： 12var stringValue = "yellow";console.log(stringValue.localeCompare("black")); //1 fromCharCode()方法接收一或多个字符编码，将它们转换为字符串。示例如下： 1console.log(String.fromCharCode(104,101,108,108,111)); //"hello" Global对象所有在全局作用域中定义的属性和方法都是Global对象的属性。除了isNaN()、isFinite()、parseInt()、parseFloat()等方法之外，Global对象还包含其他一些方法这里主要介绍常用的eval()方法，eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串，如下所示： 12eval("var msg = 'hello world'");console.log(msg); //hello world Math对象Math对象的属性 属性 说明 Math.E 自然对数的底数，即常量e的值 Math.LN2 2的自然对数 Math.LN10 10的自然对数 Math.LOG2E 以2为底的e对数 Math.LOG10E 以10为底的e对数 Math.PI Π的值 Math.SQRT1_2 1/2的平方根 Math.SQRt2 2的平方根 Math对象的方法min()、max()方法用于确定一组数值中的最小最大值 1234var max = Math.max(3,56,89,74,51,65,12);console.log(max); //89var min = Math.min(3,56,89,74,51,65,12);console.log(min); //3 舍入方法：Math.ceil()、Math.floor()、Math.round()Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。 random()方法Math.random()方法返回介于1到1之间的一个随机数，不包括0和1 其他方法 方法 说明 方法 说明 Math.abs(num) 返回num的绝对值 Math.asin(x) 返回x的反正弦值 Math.exp(num) 返回Math.E的num次幂 Math.atan(x) 返回x的反正切值 Math.log(num) 返回num的自然对数 Math.atan2(y,x) 返回y/x的反正切值 Math.pow(num,power) 返回num的power次幂 Math.cos(x) 返回x的余弦值 Math.sqrt(num) 返回num的平方根 Math.sin(x) 返回x的正弦值 Math.acos(x) 返回x的反余弦值 Math.tan(x) 返回x的正切值]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 变量、作用域和内存问题]]></title>
    <url>%2FBlog%2Fposts%2F7.html</url>
    <content type="text"><![CDATA[基本类型和引用类型的值ECMAScript变量可能包含不同数据类型的值：基本类型值和引用类型值。基本类型值：指的是简单的数据段，Undefined、Null、Boolean、Number和String这五种基本数据类型是按值访问的。引用类型值：指的是那些可能由多个值构成的对象，引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象。 动态的属性引用类型的值可以动态地添加属性和方法，也可以改变和删除其属性和方法，但是不能给基本类型的值添加属性 123456789// 为引用类型的值添加属性并给属性赋值var person = new Object();person.name = "Nicholas";console.log(person.name); // "Nicholas"//为基本类型的值添加属性会返回undefined,但是不会报错var name = "Nicholas";name.age = 27;console.log(name.age); // undefined 复制变量值基本类型值与引用类型值复制变量是不同的。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个变量可以参与任何操作而不会相互影响。 12var num1 = 5;var num2 = num1; // num1与num2的值都是5，但是他们两个相互之间没有影响 如果一个变量向另一个变量复制引用类型的值，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制结束后，两个变量实际上将引用同一个对象，改变一个变量，就会影响另一个变量。 1234var obj1 = new Object();var obj2 = obj1;obj1.name = "Nicholas";console.log(obj2.name); // "Nicholas" 传递参数ECMAScript中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数），在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。 12345678function addTen(num) &#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count); // 20console.log(result); // 30 检测类型typeof 可以检测基本数据类型，instanceof可以检测引用数据类型。根据规定，所有引用类型的值都是Object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true，使用instanceof操作符检测基本类型的值，则该操作符始终会返回false。 执行环境及作用域执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有便俩个和函数定义也随之销毁。当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在一开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境，全局执行环境中的变量对象始终都是作用域链中的最后一个对象。标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。 12345678910var color = "blue";function changeColor() &#123; if(color == "blue")&#123; color = "red"; &#125; else &#123; color == "grey"; &#125;&#125;changeColor();console.log("Color is " + color); 1Color is red 上面例子中的函数changColor()的作用域链的中包含两个对象，它自己的变量对象（其中定义着arguments）和全局环境的变量对象。作用域链为它自己的变量对象 ——&gt; 全局环境的变量对象 延长作用域链有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，在两种情况下会发生这种现象，出现以下两种现象时，执行流进入下列任何一个语句时，作用域链就会得到加长： try-catch 语句的 catch 块； with 语句。 这两个语句都会在作用域的前端添加一个变量对象，对with语句来说，会将指定的对象添加到作用域链中；对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。如下面的例子所示： 1234567function buildUrl () &#123; var qs = "?debug=true"; with(location)[ var url = href + qs; ] return url;&#125; 在这个例子中，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加进了作用域链的前端，buildUrl()函数中定义了一个变量qs，当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到，当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中，因此with内部的url就成了函数执行环境的一部分，可以作为函数的值返回。 没有块级作用域JavaScript没有块级作用域，在其他类C的语言中，由花括号封闭的代码都有自己的作用域（用ECMAScript的话来说就是他们自己的执行环境）。因而支持根据条件来定义变量，例如，下面的代码在JavaScript中并不会得到想象中的结果： 1234if (true) &#123; var color = "blue";&#125;console.log(color); //"blue" 这个例子，如果是在C、C++或Java中，color会在if语句执行完毕后被销毁，但是在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。使用for语句时也会发生这样的情况。 1234for (var i=0; i&lt;10;i++) &#123; doSomething(i);&#125;console.log(i); // 10 for循环执行结束后，由for语句创建的i依旧存在于循环外部的执行环境中。解决这种办法ES6使用let声明变量，用let声明可以将作用域限制在当前块中。声明变量：使用var声明的变量会自动被添加进最接近的环境中，在函数内部，最接近的环境就是函数的局部环境，在with语句中，最接近的环境是函数环境，如果初始化变量时没有使用var声明，该变量会自动添加进全局环境。查询标识符：搜索过程从作用域链的前端开始，向上逐级查询给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪；如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索，搜索过程一直追溯到全局环境的变量对象，如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。 垃圾收集JavaScript具有自动垃圾收集机制，垃圾收集器跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，用于标识无用变量的策略主要有以下两种办法：标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去除环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1；相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象高级编程]]></title>
    <url>%2FBlog%2Fposts%2F6.html</url>
    <content type="text"><![CDATA[数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能，我们会讨论多重继承、定制类、元类等概念。 使用slotsslots是用来限制class实例能添加的属性 12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 测试结果L: 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' 由于’score’没有被放到slots中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用slots要注意，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的： 使用@property在绑定属性时，如果我们直接向下面这样把属性暴露出去，虽然写起来简单，但是，没办法检查参数，导致成绩可以随便改 12s = Student()s.score = 9999 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 多重继承继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能，例如Animal类层的设计，假设我们要实现以下4种动物： Dog - 狗狗； Bat - 蝙蝠； Parrot - 鹦鹉； Ostrich - 鸵鸟。如果按照哺乳动物与鸟类归类，可以将Dog与Bat归为一类，Parrot与Ostrich归为一类，但是如果我们再按照能跑与能飞来分类，将非常麻烦，所以python设计多重继承 我们要给动物加上Runable与Flyable的功能，只需要定义好Runnable与Flyable的类 1234567class Runnable(object): def run(self): print('Running...')class Flyable(object): def fly(self): print('Flying...') 对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog： 12class Dog(Mammal, Runnable): pass 对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat： 12class Bat(Mammal, Flyable): pass 通过多重继承，一个子类就可以同时获得多个父类的所有功能。 MixIn在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。比如，编写一个多进程模式的TCP服务，定义如下： 12class MyTCPServer(TCPServer, ForkingMixIn): pass 编写一个多线程模式的UDP服务，定义如下： 12class MyUDPServer(UDPServer, ThreadingMixIn): pass 如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn： 12class MyTCPServer(TCPServer, CoroutineMixIn): pass 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。只允许单一继承的语言（如Java）不能使用MixIn的设计。 定制类str我们先定义一个Student类，打印一个实例： 123456&gt;&gt;&gt; class Student(object):... def __init__(self, name):... self.name = name...&gt;&gt;&gt; print(Student('Michael'))&lt;__main__.Student object at 0x109afb190&gt; 打印出一堆&lt;main.Student object at 0x109afb190&gt;，不好看。怎么才能打印得好看呢？只需要定义好str()方法，返回一个好看的字符串就可以了： 12345678&gt;&gt;&gt; class Student(object):... def __init__(self, name):... self.name = name... def __str__(self):... return 'Student object (name: %s)' % self.name...&gt;&gt;&gt; print(Student('Michael'))Student object (name: Michael) 这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看： 123&gt;&gt;&gt; s = Student('Michael')&gt;&gt;&gt; s&lt;__main__.Student object at 0x109afb310&gt; 这是因为直接显示变量调用的不是str()，而是repr()，两者的区别是str()返回用户看到的字符串，而repr()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。 解决办法是再定义一个repr()。但是通常str()和repr()代码都是一样的，所以，有个偷懒的写法： 123456class Student(object): def __init__(self, name): self.name = name def __str__(self): return 'Student object (name=%s)' % self.name __repr__ = __str__ iter如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个iter()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 我们以斐波那契数列为例，写一个Fib类，可以作用于for循环： 123456789101112class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 现在，试试把Fib实例作用于for循环： 1234567891011&gt;&gt;&gt; for n in Fib():... print(n)...11235...4636875025 getitemFib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素： 1234&gt;&gt;&gt; Fib()[5]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'Fib' object does not support indexing 要表现得像list那样按照下标取出元素，需要实现getitem()方法： 123456class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a 现在，就可以按下标访问数列的任意一项了： 12345678910111213&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[1]1&gt;&gt;&gt; f[2]2&gt;&gt;&gt; f[3]3&gt;&gt;&gt; f[10]89&gt;&gt;&gt; f[100]573147844013817084101]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <url>%2FBlog%2Fposts%2F5.html</url>
    <content type="text"><![CDATA[类和实例面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板，实例是根据类创建出来的一个个具体的“对象”。以Student类为例，定义Student类，定义类的关键字是class 12class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的： 12345&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt; Student&lt;class '__main__.Student'&gt; 可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的init方法，在创建实例的时候，就把name，score等属性绑上去： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 注意到init方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。有了init方法，在创建实例的时候，就不能传入空的参数了，必须传入与init方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 数据封装数据封装即是类的方法 12345678lass Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 在Student这个类中定义了print_score方法；和普通函数一样，要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。 12&gt;&gt;&gt; bart.print_score()Bart Simpson: 59 练习1:在Student类里定义get_grade方法，成绩在90分以上返回这个人的名字和A，60到90之间为B，60以下为C 1234567891011121314151617# -*- coding: utf-8 -*-class Student(object): def __init__(self, name, score): self.name = name self.score = score def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C'lisa = Student('Lisa', 99)bart = Student('Bart', 59)print(lisa.name, lisa.get_grade())print(bart.name, bart.get_grade()) 输出结果如下： 12Lisa ABart C 总结类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.score59&gt;&gt;&gt; bart.score = 99&gt;&gt;&gt; bart.score99 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 __ ，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改,但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法 1234567891011121314151617class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def get_name(self): #通过get_name获取内部名字等 return self.__name def get_score(self): return self.__score def set_score(self, score): #通过set_score修改内部变量，用这种办法，可以对参数进行检查，避免传入无效的参数 if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score') 需要注意的是，在Python中，变量名类似xxx的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用name、score这样的变量名。有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问name是因为Python解释器对外把name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。练习2：请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性 12345678910111213141516171819# -*- coding: utf-8 -*-class Student(object): def __init__(self, name, gender): self.name = name self.__gender = gender def get_gender(self): return self.__gender def set_gender(self,gender): self.__gender = gender# 测试:bart = Student('Bart', 'male')if bart.get_gender() != 'male': print('测试失败!')else: bart.set_gender('female') if bart.get_gender() != 'female': print('测试失败!') else: print('测试成功!') 测试结果： 1测试成功! 继承和多态继承在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印，当我们需要编写Dog和Cat类时，就可以直接从Animal类继承 123456789class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): pass 对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。继承就是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法 123456&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; dog.run()&gt;&gt;&gt; cat = Cat()&gt;&gt;&gt; cat.run()Animal is running...Animal is running... 不仅可以实现继承，同时子类可以对代码进行改进与修改 1234567891011&gt;&gt;&gt; class Dog(Animal):&gt;&gt;&gt; def run(self):&gt;&gt;&gt; print('Dog is running...')&gt;&gt;&gt; class Cat(Animal):&gt;&gt;&gt; def run(self):&gt;&gt;&gt; print('Cat is running...')Dog is running...Cat is running... 子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run(),即继承的另一个好处：多态。 多态123456789101112&gt;&gt;&gt; def run_twice(animal):&gt;&gt;&gt; animal.run()&gt;&gt;&gt; animal.run()&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running...&gt;&gt;&gt; run_twice(Cat())Cat is running...Cat is running... 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、还是Cat对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树 获取对象信息使用type() 1 基本类型可以用type()判断 123456&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type('str')&lt;class 'str'&gt;&gt;&gt;&gt; type(None)&lt;type(None) 'NoneType'&gt; 2 如果一个变量指向函数或者类，也可以用type()判断 1234&gt;&gt;&gt; type(abs)&lt;class 'builtin_function_or_method'&gt;&gt;&gt;&gt; type(a)&lt;class '__main__.Animal'&gt; 3 判断一个对象是否是函数可以使用types模块中定义的常量 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 使用isinstance()对于class的继承关系来说，使用types()就很不方便，为了判断class的类型，可以使用isinstance()函数: 1 对于如下继承关系的函数 1object -&gt; Animal -&gt; Dog -&gt; Husky 可以创建3种类型的对象，然后判断，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上 1234567891011&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Dog)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True&gt;&gt;&gt; isinstance(d, Husky)False 2 可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple: 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 使用dir()dir()函数可以获得一个对象的所有属性和方法，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 类似xxx的属性和方法在Python中都是有特殊用途的，比如len方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的len()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; 'ABC'.__len__()3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个len()方法： 1234567&gt;&gt;&gt; class MyDog(object):... def __len__(self):... return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： 123456789101112131415161718192021222324&gt;&gt;&gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject()&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z',试图获取不存在的属性，会抛出AttributeError的错误Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'MyObject' object has no attribute 'z' 可以传入一个default参数，如果属性不存在，就返回默认值： 12&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 也可以获得对象的方法： 123456789&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？True&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 实例属性和类属性由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量： 123456class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有： 12class Student(object): name = 'Student' 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 练习:为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加： 123456789101112131415161718192021# -*- coding: utf-8 -*-class Student(object): count = 0 def __init__(self, name): self.name = name Student.count += 1 # 测试:if Student.count != 0: print('测试失败!')else: bart = Student('Bart') if Student.count != 1: print('测试失败!') else: lisa = Student('Bart') if Student.count != 2: print('测试失败!') else: print('Students:', Student.count) print('测试通过!') 12Students: 2测试通过! 实例属性属于各个实例所有，互不干扰；类属性属于类所有，所有实例共享一个属性；不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归函数]]></title>
    <url>%2FBlog%2Fposts%2F4.html</url>
    <content type="text"><![CDATA[递归函数在函数内部，可以调用其他函数，如果一个函数在内部调用自身本身，这个函数就是递归函数举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。于是，fact(n)用递归的方式写出来就是： 12345678910def fact(n): if n==1: return 1 return n * fact(n - 1)&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 递归函数的优点是定义简单，逻辑清晰，使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出 尾优化解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以把循环看成一种特殊的尾递归函数也是可以的尾递归是指，在函数返回的时候，调用自身本身，并且eturn语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product) 仅返回递归函数本身，num - 1和 num * product在函数调用前就会被计算，不影响函数调用。fact(5)对应的fact_iter(5, 1)的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <url>%2FBlog%2Fposts%2F3.html</url>
    <content type="text"><![CDATA[python是面向对象编程的程序语言函数就是面向过程的程序设计的基本单元。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。 高阶函数变量可以指向函数既可以将函数赋值结果给变量，也可以将函数本身赋值给变量，即变量可以指向函数示例如下： 123456&gt;&gt;&gt; x = abs(-10)&gt;&gt;&gt; x10&gt;&gt;&gt; f=abs&gt;&gt;&gt; f&lt;built-in function abs&gt; 变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同 123&gt;&gt;&gt; f = abs&gt;&gt;&gt; f(-10)10 传入函数既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。一个最简单的高阶函数如下： 12def add(x, y, f): return f(x) + f(y) 编写高阶函数，就是让函数的参数能够接收别的函数。 map/reducePython内建了map()和reduce()函数。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回示例如下： 12345678&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; tuple(r)(1, 4, 9, 16, 25, 36, 49, 64, 81) map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数或者tuple()函数让它把整个序列都计算出来并返回一个listreduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 练习1: 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]： 12345678&gt;&gt;&gt; # -*- coding: utf-8 -*-&gt;&gt;&gt; def normalize(name):&gt;&gt;&gt; return name.capitalize()&gt;&gt;&gt;# 测试:&gt;&gt;&gt; L1 = ['adam', 'LISA', 'barT']&gt;&gt;&gt; L2 = list(map(normalize, L1))&gt;&gt;&gt; print(L2)['Adam', 'Lisa', 'Bart'] 练习2: Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积： 1234567891011&gt;&gt;&gt; # -*- coding: utf-8 -*-&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def prod(L):&gt;&gt;&gt; return reduce(lambda x, y: x * y, L)&gt;&gt;&gt; print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))&gt;&gt;&gt; if prod([3, 5, 7, 9]) == 945:&gt;&gt;&gt; print('测试成功!')&gt;&gt;&gt; else:&gt;&gt;&gt; print('测试失败!')3 * 5 * 7 * 9 = 945测试成功! filterPython内建的filter()函数用于过滤序列,用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list.示例如下：用filter求素数计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：首先，列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …不断筛下去，就可以得到所有的素数。 123456789101112131415161718192021222324# 用Python来实现这个算法，可以先构造一个从3开始的奇数序列：def _odd_iter(): n = 1 while True: n = n + 2 yield n# 然后定义一个筛选函数：def _not_divisible(n): return lambda x: x % n &gt; 0# 最后，定义一个生成器，不断返回下一个素数：def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列#由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：# 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 练习3: 回数是指从左向右读和从右向左读都是一样的数，例如 12321 ， 909 。请利用 filter() 滤掉非回数 12345678方案一:def is_palindrome(n): nn = str(n) #转成字符串 return nn == nn[::-1] #反转字符串并对比原字符串返回true/falseprint list(filter(is_palindrome,range(1,1000)))方案二:print list(filter(lambda n : str(n)==str(n)[::-1],range(1,1000))) #str(n)同上 sortedsorted()也是一个高阶函数，用sorted()排序的关键在于实现一个映射函数练习4：假设我们用一组tuple表示学生名字和成绩：L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]请用sorted()对上述列表分别按名字排序： 123456# -*- coding: utf-8 -*-L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_name(t): return t[0].lower()L2 = sorted(L, key=by_name)print(L2) 输出结果如下： 1[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)] 再按成绩从高到低排序： 123456# -*- coding: utf-8 -*-L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def by_score(t): return t[1]L2 = sorted(L, key=by_score)print(L2) 输出结果如下： 1[('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)] 返回函数函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回示例如下： 12345678910111213141516&gt;&gt;&gt; def lazy_sum(*args):&gt;&gt;&gt; def sum():&gt;&gt;&gt; ax = 0&gt;&gt;&gt; for n in args:&gt;&gt;&gt; ax = ax + n&gt;&gt;&gt; return ax&gt;&gt;&gt; return sum&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9) #当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f() #调用函数f时，才真正计算求和的结果25&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2 #f1()和f2()的调用结果互不影响。False 闭包注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。练习5：利用闭包返回一个计数器函数，每次调用它返回递增整数 1234567891011121314151617# -*- coding: utf-8 -*-def createCounter(): s = [0] def counter(): s[0] = s[0]+1 return s[0] return counter# 测试:counterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5counterB = createCounter()if [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]: print('测试通过!')else: print('测试失败!')1 2 3 4 5测试通过! 匿名函数关键字lambda表示匿名函数，冒号前面的x表示函数参数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数示例如下： 12345&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;&gt;&gt;&gt; f(5)25 装饰器12345678910&gt;&gt;&gt; def now():... print('2015-3-25')...&gt;&gt;&gt; f = now #由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数&gt;&gt;&gt; f()2015-3-25&gt;&gt;&gt; now.__name__ #函数对象有一个__name__属性，可以拿到函数的名字'now'&gt;&gt;&gt; f.__name__'now' 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。简单例子如下： 123456789import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 具体见廖雪峰学习网站，这里不具体介绍装饰器]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级特性]]></title>
    <url>%2FBlog%2Fposts%2F2.html</url>
    <content type="text"><![CDATA[切片取一个list或tuple的部分元素是非常常见的操作，例如，一个lst如下： 1L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack'] 用切片可以选择任意位置取元素 123L[0:3] #取前三个元素L[:] #全部复制L[-2:] #从倒数第二个向后取 输出结果如下所示： 123['Michael', 'Sarah', 'Tracy']['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']['Bob', 'Jack']] 同理字符串也可以这样操作 迭代Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以用在其他可迭代对象上。举例：dict迭代 123d = &#123;'a': 1, 'b': 2, 'c': 3&#125;for key in d: print(key) 输出结果为： 123acb 因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： 123&gt;&gt;&gt; from collection import Iterable&gt;&gt;&gt; isinstance('abc',Iterable) #是否可迭代&gt;&gt;&gt; True 若对list实现类似Java那样的下标循环，可以使用Python内置的enumerate函数可以把一个list变成索引-元素对 12345&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):&gt;&gt;&gt; print(i, value)0 A1 B2 C 请使用迭代查找一个list中最小和最大值，并返回一个tuple：自己写的示例代码 1234567891011def findMinAndMax(L):if L==[]: return(None,None) else: min=max=L[0] for i in L: if i&lt;min: min=i if i&gt;max: max=i return(min,max) 列表生成式列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))： 12&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x*x for x in range(1,11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value,列表生成式也可以使用两个变量来生成list： 12&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()] 输出结果如下： 1['y=B', 'x=A', 'z=C'] 练习题： L1为 [‘Hello’, ‘World’, 18, ‘Apple’, None]，输出 L2为 [‘hello’, ‘world’, ‘apple’]代码如下： 1L2 = [i.lower() for i in L1 if isinstance(i, str)==True] 生成器通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 123456&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值： 1234&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误不想一个一个打印也可以用for循环进行打印 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)0149162536496481 第二种创建generator的办法是使用yield关键字generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。练习题：杨辉三角 12345 1 1 1 1 2 1 1 3 3 11 4 6 4 1 把每一行看做一个list，试写一个generator，不断输出下一行的list： 1234567891011def triangles(): a=[1] while True: yield a a=[sum(i) for i in zip([0]+a,a+[0])]n=0for t in triangles(): print(t) n=n+1 if n == 10: break 迭代器凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。Python的for循环本质上就是通过不断调用next()函数实现的，例如： 12for x in [1, 2, 3, 4, 5]: pass 实际上完全等价于： 12345678910# 首先获得Iterator对象:it = iter([1, 2, 3, 4, 5])# 循环:while True: try: # 获得下一个值: x = next(it) except StopIteration: # 遇到StopIteration就退出循环 break]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 基础]]></title>
    <url>%2FBlog%2Fposts%2F0.html</url>
    <content type="text"><![CDATA[数据类型和变量数据类型数据类型分为整数、浮点数、字符串、布尔值和空值 变量变量可以是数字与任意数据类型 字符编码字符编码使用UTF-8标准 Python的字符串Python的字符串支持多语言，对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b'ABC' 注意：区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节 以Unicode表示的str通过encode()方法可以编码为指定的bytes英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。在bytes中，无法显示为ASCII字符的字节，用\x##显示。反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法len()函数计算的是str的字符数，如果换成bytes，len()函数计算字节数 格式化运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。常见的占位符有：%d（整数） %f（浮点数） %s（字符串） %x（十六进制整数）还有一种方式是format()方法使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多示例如下： 1'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125) list和tuplelistPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。示例如下： 1classmates = ['Michael', 'Bob', 'Tracy'] 变量classmates就是一个list，list的索引是从0开始的，最后一个元素的索引是len(classmates)-1除此之外，还可以用-1做索引,以此类推-2、-3等等 12&gt;&gt;&gt;classmates[-1]'Tracy' list中的经常使用的方法： 1append()list是一个可变的有序表，所以，可以往list中追加元素到末尾 123&gt;&gt;&gt; classmates.append('Adm')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adm'] 2insert()list可以把元素插入到指定的位置，比如索引号为1的位置 123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adm'] 3pop()删除list末尾的元素 123&gt;&gt;&gt; classmates.pop()&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 123&gt;&gt;&gt; classmates.pop(1)&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] pop(i)是删除指定位置的元素 4把某个元素替换成别的元素 123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] 5list元素也可以是另一个list，比如： 123&gt;&gt;&gt; s = ['python', 'java',['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4 tupletuple是另一种有序列表即元祖，与list非常类似，但是tuple一旦初始化后就不能修改。 1&gt;&gt;&gt; classmates('A', 'B', 'C') 现在这个classmates不能修改了，没有append，insert，pop等方法，只能正常使用classmates[0],classmates[-1],但是不能赋值成其他元素。使得代码更安全定义只有一个元素的tuple时必须加逗号，避免歧义 123456&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1) 这是因为Python规定，这种情况下，按小括号进行计算，计算结果自然是1。tuple里也可以定义可变的list 12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) 条件判断if、 if else、 if elif else if语句1234age = 20if age &gt;= 18: print('your age is', age) print('adult') if else语句1234567age = 3if age &gt;= 18: print('your age is', age) print('adult')else: print('your age is', age) print('teenager') if elif else语句1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环Python 的循环有两种，一种是for…in循环，另一种是while循环。 for…in循环作用是依次把list或者tuple中的每个元素迭代出来。 123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) 输出结果如下： 123MichaelBobTracy while循环只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现。 123456um = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。 breakbreak语句可以提前结束退出循环 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') continue可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) dict和setdictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 注意事项：1.一个key对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉2.key不存在，dict就会报错避免方式：一是通过in判断key是否存在 二是通过dict的get()方法，如果key不存在，可以返回None，或者自己指定的value3.删除key，用pop(key)方法，对应的value也会从dict中删除 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。要创建一个set，需要提供一个list作为输入集合： 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。重复元素在set中自动被过滤： 123&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; set的增删方法： add(key): 添加元素到set中，可重复添加，但是不会有效果remove(key): 删除元素]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 基本函数]]></title>
    <url>%2FBlog%2Fposts%2F1.html</url>
    <content type="text"><![CDATA[基本函数语法定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。我们以自定义一个求绝对值的my_abs函数为例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 调用函数12&gt;&gt;&gt; print(my_abs(-99))99 空函数定义一个什么也不做的空函数 12def nop(): pass # pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来 参数检查参数个数检查，python解释器会自动检查出来，并抛出TypeError参数类型检查，使用isinstance() 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 若输入参数出现错误，会抛出一个错误 函数的参数位置参数1234def power(x): return x * x&gt;&gt;&gt; power(5)&gt;&gt;&gt; 25 12345678def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s&gt;&gt;&gt; power(5,3)125 根据定义的参数个数传入几个位置参数 默认参数设置的默认参数也可以在函数调用时明确传入，更改默认参数 12345678910def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 3)125 注意：默认参数必须指向不变对象 可变参数当参数个数不确定时，我们可以把这些不确定的参数当作一个list或者tuple传递进来例如：以数学题为例，给定一组a,b,c,……，计算他们的平方和 123456789def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 这种方式需要先组装出一个list或者tuple但是利用可变参数，调用函数的方式可以简化成这样： 123456789def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个 * 号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数如果已经有一个list或者tuple，要调用一个可变参数,Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 关键字参数可变参数传入0个或者任意多个参数，在调用时自动组装为一个tuple，关键字参数传入0个或者多个含参数名的参数，这些关键字参数在函数内部自动组装成一个dict示例如下： 123456def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw)&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 命名关键字参数如果要限制关键字参数的名字，可以用命名关键字参数示例如下： 1234def person(name, age, *, city, job): print(name, age, city, job)&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer 和关键字参数*kw不同，命名关键字参数需要一个特殊分隔符，后面的参数被视为命名关键字参数但是如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符了 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错 123456def person(name, age, *args, city, job): print(name, age, args, city, job)&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数** 关键字参数与命名关键字参数对应的是字典dict，可变参数对应的是元组]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM选择器]]></title>
    <url>%2FBlog%2Fposts%2F12.html</url>
    <content type="text"><![CDATA[属性选择器属性选择器是在CSS2中引入的，他们能够指定一些规则，这些规则根据元素的属性（诸如href或title）以及这些属性的值对元素进行匹配 12345&lt;ul&gt; &lt;li&gt;&lt;a href="" lang="en-GB" rel="friend net"&gt;Peter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" lang="es-ES" rel-"fiend"&gt;Pedro&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" lang="es-MX" rel-"contact"&gt;Pancho&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 简单属性选择器将规则应用到定义了指定属性的元素上，而不管属性的值是什么 123a[rel] &#123; color: red;&#125; 由于所有元素都有rel属性，所以所有元素都会应用这条规则 精确属性值选择器123a[rel='friend'] &#123; color: red;&#125; 这个代码只会将规则标记到第二个a元素 部分属性选择器123a[rel~='friend'] &#123; color: red;&#125; 这个代码会选择rel属性中带有friend的值的元素，则这个规则会标记到第一与第二个 语言属性选择器123a[lang|='es'] &#123; color: red;&#125; 选中所有属性值以es开头的lang语言，即会选中2和3 CSS3的新属性选择器开始字串属性值选择器（开始选择器）该选择器会选择一些元素，这些元素所选择的属性是以一个字符串为起始，该字符串会作为参数提供给选择器，这个选择器使用插入符号(^)修饰属性中的等号 1E[attr^='value'] &#123;&#125; 这行代码将在指定属性的起始处寻找指定的值示例如下： 123456&lt;p&gt;Lorem ipsum dolor &lt;a href="mailto:email@example.com"&gt;email&lt;a&gt; sit amet.&lt;/a&gt;&lt;/p&gt;&lt;style&gt;a[href^='mailto'] &#123; background-image: url('email_go.png');&#125;&lt;/style&gt; 输出结果为： 1Lorem ipsum dolor email sit amet. #这里的email是一个地址即上述href绑定的地址 email原为一图片索引，本人懒就没放图片 结束子串属性值选择器（结束选择器）与开始选择器相反，使用该选择器去选择以指定的值结束的属性语法差异为用($)去修饰(=) 任意子串属性值选择器（任意选择器）该选择器使用规则即在指定的属性字符串的内部任意位置搜索指定的子串该选择器使用的符号是(*) 多属性选择器可以把多个选择器串接在一起，这样在选择目标的时候能够做到非常的具体，使用多选择器，可以通过定义在开始、结束以及中间任意位置的值创建应用到属性上的规则 12&lt;p&gt;&lt;a href="http://example.com/folder1/file.pdf"&gt;Lorem ipsum&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="http://example.com/folder2/file.pdf"&gt;Lorem ipsum&lt;/a&gt;&lt;/p&gt; 如果要指定一条只应用到第二个p元素的规则，可以把一些选择器串接到一起： 1a[href^='http://'][href*='/folder2/'][href$='.pdf'] &#123;&#125; 这行代码会寻找这样的a元素，它具有一个href属性，是以 http: // 开始，以.pdf结束，并且在中间包含了/folder2/，非常明确 普通兄弟连结符12E + F &#123;&#125; #相邻兄弟连结符E ~ F &#123;&#125; #普通兄弟连结符 相邻兄弟连结符选择的是文档树的同一层级，紧邻在元素(E)之后的任意元素；普通兄弟连结符选择的是文档树的同一层级，位于元素(E)之后的任意元素。示例如下： 12345678910111213141516&lt;p&gt;Next we are going to discuss ... &lt;/p&gt;&lt;h2&gt;Ren&amp;eacute; Descartes&lt;/h2&gt;&lt;p&gt;A highly influential French philosopher...&lt;/p&gt;&lt;p&gt;He only famously declared:&lt;/p&gt;&lt;blockquote&gt; &lt;p&gt;I think,therefore I am.&lt;/p&gt;&lt;/blockquote&gt; &lt;p&gt;However,this presumes the existence of the speaker.&lt;/p&gt;&lt;style&gt;h2 + p &#123; font-weight:bolder;&#125;h2 ~ p &#123; font-style: italic;&#125;&lt;/style&gt; 输出结果如下：]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS工作原理]]></title>
    <url>%2FBlog%2Fposts%2F11.html</url>
    <content type="text"><![CDATA[每个HTML元素都有一组样式属性，可以通过CSS来设定。这些属性涉及元素在屏幕上显示时的不同方面，比如在屏幕上位置、边框的宽度，文本内容的字体、字号和颜色，等等。CSS就是一种先选择HTML元素，然后设定选中元素CSS属性的机制。CSS选择符和要应用的样式构成了一条CSS 规则。 剖析CSS规则规则实际上就是一条完整的CSS 指令。规则声明了要修改的元素和要应用给该元素的样式。下面就是一条CSS规则，它可以把段落的文本设置为红色。 1p &#123;color: red;&#125; 把以上代码放到我们的HTML5模板中。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; /*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*/ p &#123;color: red;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This text is very important!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; &lt;body&gt;元素中的&lt;p&gt;字段就会变成红色。为文档添加样式的三种方法：有三种方法可以把CSS添加到网页中，分别是写在元素标签里（也叫行内样式）、写在&lt;style&gt;标签里（也叫嵌入样式）和写在单独的CSS样式表中（也叫链接样式）。行内样式行内样式是写在特定HTML标签的style属性里的，比如： 123&lt;p&gt;This paragraph simply takes on the browser default paragraph style.&lt;/p&gt;&lt;p style="font-size: 12px; font-weight:bold; font-style:italic; color:red;"&gt;Byadding inline CSS styling to this paragraph, you override the default styles.&lt;/p&gt; 行内样式的作用范围非常有限，行内样式只能影响它所在的标签，而且总会覆盖嵌入样式和链接样式。嵌入样式嵌入的CSS样式是放在HTML文档的head元素中的，比如： 1234567&lt;head&gt;&lt;!-- 其他head 元素（如meta、title）放在这里 --&gt;&lt;style type="text/css"&gt;h1 &#123;font-size:16px;&#125;p &#123;color:blue;&#125;&lt;/style&gt;&lt;/head&gt; 嵌入样式的应用范围仅限于当前页面。页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖。像本书前面例子中那样使用嵌入方式为某个组件（比如菜单）设计样式是很方便的，因为HTML 和CSS 同在一页，可以互相参照。但是，等到CSS 样式设计完毕，组件功能齐备之后，还是应该把相应的样式转移到外部样式表，以便其他页面也能共用相同的样式。链接样式在创建包含多个页面的网站时，需要把样式集中在一个单独的文件里，这个文件就叫样式表。样式表其实就是一个扩展名为.css 的文本文件。可以在任意多个HTML 页面中链接同一个样式表文件，每个页面中只需加入类似下面的这一行代码即可： 1&lt;link href="style.css" rel="stylesheet" type="text/css" /&gt; 链接样式的作用范围可以是整个网站。只要使用&lt;link&gt;标签把样式表链接到每个页面，相应的页面就可以使用其中的样式。随后，只要修改了样式表中的样式，改动就会在所有被选中的元素上体现出来，无论这个元素在哪个页面里。这样，既可以做到全站页面外观统一，又便于整站样式更新。除了以上三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法，那就应用@import 指令（是一种at 规则）： 1@import url(css/styles2.css) 要注意的是，@import 指令必须出现在样式表中其他样式之前，否则@import 引用的样式表不会被加载。有一点很重要，那就是CSS 样式是通过&lt;style&gt;标签嵌入到页面里的。当浏览器遇到开标签&lt;style&gt;时，就会由解释HTML 代码切换为解释CSS 代码。等遇到闭标签&lt;/style&gt;时，它会再切换回解释HTML 代码。对于写在样式表里的样式，就不需要&lt;style&gt;标签了。如果你在样式表里加上这个标签，样式表中的样式就不会被浏览器加载了。 CSS规则命名惯例CSS规则由选择符和声明两部分组成，其中选择符用于指出规则所要选择的元素，声明则又由两部分组成：属性和值，属性指出要影响哪方面的样式，值就是属性的一个新状态。如下图所示：对这个基本的结构，有三种方法可以进行扩展。第一种方法：多个声明包含在一条规则里。 1p &#123;color:red; font-size:12px; font-weight:bold;&#125; 第二种方法：多个选择符组合在一起。 123h1 &#123;color:blue; font-weight:bold;&#125;h2 &#123;color:blue; font-weight:bold;&#125;h3 &#123;color:blue; font-weight:bold;&#125; 第三种方法：多条规则应用给一个选择符。 12h1, h2, h3 &#123;color:blue; font-weight:bold;&#125;h3 &#123;font-style:italic;&#125; 所有用于选择特定元素的选择符又分三种。 上下文选择符。基于祖先或同胞元素选择一个元素。 ID 和类选择符。基于id 和class 属性的值（你自己设定）选择元素。 属性选择符。基于属性的有无和特征选择元素。 上下文选择符像这种“基于位置”变换某个标签样式的问题，可以用上下文选择符来解决。上下文选择符的格式如下： 1标签1 标签2 &#123;声明&#125; 其中，标签2就是我们想要选择目标，而且只有标签1是其祖先元素（不一定是父元素）的情况下才会被选中。上下文选择符，也叫后代组合式选择符，就是一组以空格分隔的标签名，用于选择作为指定祖先元素后代的标签。如下所示： 1article p &#123;font-weight: bold;&#125; 上面这个例子的上下文选择符表明，只有是article后代的p元素才会应用后面的样式。 特殊的上下文选择符上面介绍的上下文选择符是以某个祖先标签作为上下文，不过，有时候我们可能还会需要比“某些祖先”更加具体的上下文。比如说吧，要是你想根据父元素或者同胞元素的标签名来选择元素怎么办呢？下面我们再用另一段标记来演示几种特殊的上下文选择符。 123456&lt;section&gt; &lt;h2&gt;An H2 Heading&lt;/h2&gt; &lt;p&gt;This is paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2 has &lt;a href="#"&gt;a link&lt;/a&gt; in it.&lt;/p&gt; &lt;a href="#"&gt;Link&lt;/a&gt;&lt;/section&gt; 子选择符&gt;1标签1 &gt; 标签2 标签2必须是标签1的子元素，或者反过来说，标签1必须是标签2的父元素，不能是其他祖先元素。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; /*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*/ section &gt; h2 &#123;font-style:italic;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;h2&gt;An H2 Heading&lt;/h2&gt; &lt;p&gt;This is paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2 has &lt;a href="#"&gt;a link&lt;/a&gt; in it.&lt;/p&gt; &lt;a href="#"&gt;Link&lt;/a&gt; &lt;/section&gt; &lt;/body&gt;&lt;/html&gt; 展示效果如下所示： 紧邻同胞选择符+标签1 + 标签2标签2必须紧跟在其同胞标签1的后面 1h2 + p &#123;font-variant:small-caps;&#125; 一般同胞选择符~标签1 ~ 标签2标签2必须跟（不一定紧跟）在其同胞标签1后面 1h2 ~ a &#123;color: red;&#125; 通用选择符*通用选择符是*（常被称为星号选择符）是一个通配符，它匹配任何元素，下面这条规则会导致所有元素（的文本和边框）都变成绿色。 1* &#123;color: green;&#125; 如上图所示，直接匹配会将所有元素都变成绿色，不过大多数情况在使用*选择符时，会同时使用另一个选择符，如下所示： 1234/*将p包含的所有元素的文本变成红色。*/p * &#123;color: red;&#125;/*，任何是section 孙子元素，而非子元素的a 标签都会被选中。至于a的父元素是什么，没有关系。*/section * a &#123;font-size:1.3em;&#125; ID和类选择符ID 和类为我们选择元素提供了另一套手段，利用它们可以不用考虑文档的层次结构。只要你在HTML 标记中为元素添加了id 和class 属性，就可以在CSS 选择符中使用ID 和类名，直接选中文档中特定的区域。可以给id 和class 属性设定任何值，但不能以数字或特殊符号开头 类属性类属性就是HTML 元素的class 属性，body 标签中包含的任何HTML 元素都可以添加这个属性。下面这段代码展示了HTML class 属性的用法。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; /*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*/ p &#123;font-family:helvetica, sans-serif; font-size:1.2em;&#125; .specialtext &#123;font-style:italic;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class="specialtext"&gt;This is a heading with the &lt;span&gt;same class&lt;/span&gt; as the second paragraph.&lt;/h1&gt; &lt;p&gt;This tag has no class.&lt;/p&gt; &lt;p class="specialtext"&gt; When a tag has a class attribute, you can target it &lt;span&gt;regardless&lt;/span&gt; of its position in the hierarchy.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 结果如下所示： 两个段落中文本的字体都变成了Helvetica，而标题和第二个段落都有specialtext 类，所以都变成了斜体 类选择符：p {font-family:helvetica, sans-serif; font-size:1.2em;}.specialtext {font-style:italic;} 标签带类选择符：p {font-family:helvetica, sans-serif; font-size:1.2em;}.specialtext {font-style:italic;}p.specialtext {color:red;} 多类选择符：&lt;p class=&quot;specialtext featured&quot;&gt;Here the span tag &lt;span&gt;may or may not&lt;/span&gt;be styled.&lt;/p&gt;.specialtext.featured {font-size:120%;} ID属性ID 与类的写法相似，而且表示ID 选择符的#（井号）的用法，也跟表示类选择符的.（句号）类似。如果有一个段落像下面这样设定了ID 属性 1&lt;p id="specialtext"&gt;This is the special text.&lt;/p&gt; 那么，相应的ID 选择符就是这样的： 1#specialtext &#123;CSS 样式声明&#125; 什么时候用ID，什么时候用类什么时候用ID:ID的用途是在页面中唯一地标识一个元素，每个ID在页面中都只能用一次。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;An HTML Template&lt;/title&gt; &lt;style&gt; #mainmenu a &#123;color:orange;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav id="mainmenu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;Yin&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Yang&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/body&gt;&lt;/html&gt; 在这里，页面中就不能再有其他元素使用mainmenu 作为ID 名了。为了标识页面的某一部分，比如主导航菜单，可以为nav（navigation，导航）添加一个ID 属性，并让它包含菜单元素。 什么时候使用类类的目的是为了标识具有相同特征的元素，示例如下： 12345678910&lt;nav&gt; &lt;ul&gt; &lt;li class="boy"&gt;&lt;a href="#"&gt;Alan&lt;/a&gt;&lt;/li&gt; &lt;li class="boy"&gt;&lt;a href="#"&gt;Andrew&lt;/a&gt;&lt;/li&gt; &lt;li class="girl"&gt;&lt;a href="#"&gt;Angela&lt;/a&gt;&lt;/li&gt; &lt;li class="boy"&gt;&lt;a href="#"&gt;Angus&lt;/a&gt;&lt;/li&gt; &lt;li class="girl"&gt;&lt;a href="#"&gt;Anne&lt;/a&gt;&lt;/li&gt; &lt;li class="girl"&gt;&lt;a href="#"&gt;Annette&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 在上面的列表中用类标记出了性别，然后再用CSS为链接应用颜色 12.boy a &#123;color:#6CF;&#125;/*蓝色*/.girl a &#123;color:#F9C;&#125;/*粉红色*/ 总结：ID 的用途是在页面标记中唯一地标识一个特定的元素。它能够为我们编写CSS 规则提供必要的上下文，排除无关的标记，而只选择该上下文中的标签。相对来说，类是可以应用给任意多个页面中的任意多个HTML 元素的公共标识符，以便我们为这些元素应用相同的CSS 样式。而且，使用类也让为不同标签名的元素应用相同的样式成为可能。 属性选择符标签名[属性名]选择任何带有属性名的标签名如下所示： 1img[title] &#123;border: 2px solid blue;&#125; 带有title 属性的HTML img 元素显示2 像素宽的蓝色边框 属性值选择符标签名[属性名=”属性值”]选择带有值为属性值的属性名的标签名示例如下： 1img[title="red flower"] &#123;border:4px solid green;&#125; 在图片的title 属性值为red flower 的情况下，才会为图片添加边框。 伪类伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。UI(User Interface, 用户界面)伪类会在HTML元素处于某个状态时(比如鼠标指针位于链接上)，为该元素应用CSS样式。结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用CSS样式。 UI伪类UI伪类会基于特定HTML元素的状态应用样式。最常使用UI伪类的元素是链接（a元素），利用UI伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。 链接伪类：针对链接的伪类一共有4个，因为链接始终会处于如下4种状态之一。 Link: 此时，链接就在那儿等着用户点击； Visited: 用户此前点击过这个链接； Hover: 鼠标指针正悬停在链接上。 Active：链接正在被点击（鼠标在元素上按下，还没有释放）。以下是这些状态对应的4个伪类选择符（使用了a选择符和一些示例声明）： 1234a: link &#123;color: black;&#125;a: visited &#123;color: gray;&#125;a: hover &#123;text-decoration:none;&#125;a: active &#123;color:red;&#125; 一个冒号（:）表示伪类，两个冒号（::）表示CSS3 新增的伪元素。根据前面的声明，链接在初始状态时是黑色（默认带下划线）。当鼠标移到上面时（悬停状态），链接的下划线消失，颜色仍然是黑色。当用户在链接上按下鼠标时（活动状态），链接变成红色。而在链接被点击后，也就是鼠标在链接上按下，又在链接上释放后，会触发浏览器打开URL，此后（或者更准确地说，到浏览器访问历史中的这个URL 过期或被用户删除之前），链接会一直显示为灰色。注意：有些伪类可以用于任何元素，而不仅仅是a元素，比如下面这条规则能让段落背景在鼠标悬停时变成灰色: 1p:hover &#123;background-color:gray;&#125; 2.:focus伪类 1e:focus #在这个以及后续的例子中，e 表示任何元素，如p、h1、section，等等 表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。下面的规则会在光标位于input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。 1input:focus &#123;border:1px solid blue;&#125; 3.target 伪类 1e:target 如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。示例如下： 123&lt;a href="#more_info"&gt;More Information&lt;/a&gt;&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/h2&gt;#more_info:target &#123;background:#eee;&#125; 上面的指的是在用户单击链接转向ID 为more_info 的元素时，为该元素添加浅灰色背景。 结构化伪类结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。 :first-child 和 :last-child 12e:first-childe:last-child :first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。比如，，把下面的规则 1ol.results li:first-child &#123;color:blue;&#125; 应用给以下标记：文本“My Fast Pony”就会变成蓝色。 12345&lt;ol class="results"&gt; &lt;li&gt;My Fast Pony&lt;/li&gt; &lt;li&gt;Steady Trotter&lt;/li&gt; &lt;li&gt;Slow Ol' Nag&lt;/li&gt;&lt;/ol&gt; 如果选择符改成这样：那变成红色的文本就是“Slow Ol’ Nag”。 1ol.results li:last-child &#123;color:red;&#125; 2 :nth-child 1e:nth-child(n) e 表示元素名，n 表示一个数值（也可以使用odd 或even）例如：下面会选择一组列表项中的每个第三项。 1li:nth-child(3) 伪元素伪元素就是文档中若有实无的元素。以下我们介绍几个最有用的伪元素 1 ::first-letter 伪元素 1e::first-letter 比如应用下面的CSS规则，可以得到段落首字符放大的效果。 1p::first-letter &#123;font-size:300%;&#125; 2 ::first-line 伪元素 1e::first-line 可以选中文本段落（一般情况下是段落）的第一行，如下所示：可以把第一行以小型大写字母显示 1p::first-line &#123;font-variant:small-caps;&#125; 3 ::before 和::after 伪元素 12e::beforee::after 可用于在特定元素前面或后面添加特殊内容。如下面的样式所示： 12p.age::before &#123;content:"Age: ";&#125;p.age::after &#123;content:" years.";&#125; 放入以下标记： 1&lt;p class="age"&gt;25&lt;/p&gt; 得到结果如下所示：Age: 25 years. 继承CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多CSS 属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距，这些下一章专门讲解 层叠层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。 样式来源浏览器层叠各个来源样式的顺序： 浏览器默认样式表 用户样式表 作者链接样式表(按照它们连接到页面的先后顺序) 作者嵌入样式 作者行内样式 浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式显示出来。给网页添加样式的三种方法：链接样式、 嵌入样式、 行内样式。 层叠规则层叠规则一：找到应用给每个元素和属性的所有声明。。浏览器在加载每个页面时，都会据此查到每一条CSS 规则，标识出所有受到影响的HTML 元素。层叠规则二：按照顺序和权重排序。浏览器依次检查5个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查完页面中所有标签受影响属性的全部5 个来源为止。最终某个属性被设定成什么值，就用什么值来显示。层叠规则三：按特指度排序。特指度（specificity）其实表示一条规则有多明确。类名选择符比普通的标签选择符具有更高的特指度。一条规则的特指度，由它的选择符中包含多少个标签、类名和ID 决定。 计算特指度方法： 123456I - C - E三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：1. 选择符中有一个ID，就在I 的位置上加1；2. 选择符中有一个类，就在C 的位置上加1；3. 选择符中有一个元素（标签）名，就在E 的位置上加1；4. 得到一个三位数。 例子如下： 12345678P 0-0-1 特指度=1p.largetext 0-1-1 特指度=11p#largetext 1-0-1 特指度=101body p#largetext 1-0-2 特指度=102body p#largetext ul.mylist 1-1-3 特指度=113body p#largetext ul.mylist li 1-1-4 特指度=114在此，每个选择符都比前一个选择符的特指度更高。 层叠规则四：顺序决定权重。如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出。 规则声明一个声明包含两部分：属性和值。属性指出要影响元素的哪个方面（颜色、高度，等等），而值表示把属性设定为什么（绿色、12px，等等）。CSS 属性值主要分以下三类：文本值：例如，font-weight:bold 声明中的bold 就一个文本值。文本值也叫做关键字。数字值：数字值后面都有一个单位，例如英寸或点。在声明font-size:12px 中，12是数字值，而px 是单位（像素）。如果数字值为0，那么就不用带单位了。颜色值：颜色值可以用几种不同的格式来写，包括RGB（Red, Green, Blue，红绿蓝）、HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如color:#336699）。]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
</search>
